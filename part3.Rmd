---
title: "part3"
author: "me"
date: "12 joulukuuta 2019"
output: html_document
---

# Poolaus

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

paketit<-c("readr","tidyr","dplyr","plyr","magrittr","purrr","data.table","plotrix","jtools","sp","GISTools","rgdal","sf","spatialEco","ggplot2")
lapply(paketit,library,character.only=T)
```
## Presence/absence -aineisto


### Aineisto sisälle ja periodien keskiarvojen lasku
Luetaan havainnot ja ennusteet sisään ja lasketaan kullekin lajille periodien 1 ja 2 ennustettujen ja todellisten esiintymistodennäköisyyksien reittikohtaiset keskiarvot.

```{r }
getwd()
localDir = "."
PredictionDir = file.path(localDir, "data")

samples = 1000
thin = 10
nChains = 4
modeltype = 1 #1 on pa-aineistolle

#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
dim(mpred1)
ns=dim(mpred1)[2]
dim(mpred2)
dim(Y)
dim(studyDesign)

#määritellään periodit 
period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

#valitaan ennusteista ja havainnoista oikeat vuodet
pm1p1=mpred1[period1,]  
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2

y1=Y[period1,]
y2=Y[period2,]

#lasketaan kuinka monta kertaa kullakin linjalla on k?yty
sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

#lasketaan kullekin linjalle (jolla on käyty kahdesti kummankin periodin aikana, yhteensä 592 kpl) keskiarvot periodeittain
#havainnot ja ennusteet erikseen, periodit 1 ja 2 erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for (i in 1:nsr){
  take1 = which(sd1$Route == selroutes[i] )
  take2 = which(sd2$Route == selroutes[i] )
  Ap1[i,] = colMeans(pm1p1[take1,])
  Ap2[i,] = colMeans(pm1p2[take2,]) 
  Ay1[i,] = colMeans(y1[take1,]) #Suomen vesilinnut vain NA:ta
  Ay2[i,] = colMeans(y2[take2,])
}
```

Kolme reittiä taitaa olla Suomessa, joten niiden kohdalla vesilintujen havainnot ovat NA:ta.


### Koordinaattien lisääminen 

Seuraavaksi liitetään kuhunkin reittiin koordinaatit.

```{r}
#lisätään kullekin linjalle koordinaatit
routeyear<-read.csv("studydesign.csv",header=T,sep=",")
xy<-read.csv("xy.csv",header=T,sep=",")

#koordinaateista puuttuu nollia
xy<-xy%>%
  mutate(x = x * 1000) %>%
  mutate(y = y * 1000) 

#jotta koordinaatit saa liitetty? oikealle linjalle, tehdään taulukko, jossa reiteillä on molemmat koodaukset (alkuperäiset ja 1-2591)
Route<-unique(routeyear$Route)
routeid<-c(1:2591)
d<-data.frame(Route,routeid)

#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja vihdoin myös koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))
```
Ylläolevaa koodin pätkää voi vielä siloitella jos on aikaa.

Tallennan havainnot ja ennusteet, jolloin poolausta on helpompi tarkistaa GIS:llä.

```{r}
#tallenna tiedot
write.csv(Ay1,"pa_obs_per1.csv",row.names = F)
write.csv(Ay2,"pa_obs_per2.csv",row.names = F)
write.csv(Ap1,"pa_pred_per1.csv",row.names = F)
write.csv(Ap2,"pa_pred_per2.csv",row.names = F)
```


### Poolaus

Kootaan reitit 50 km x 50 km (tai 100x100 km) ruutuihin, eli lasketaan todelliset ja ennustetut esiintymistodennäköisyydet kaikkien yhteen ruutuun sijoittuvien reittien periodien keskiarvojen keskiarvoina.  

Luetaan ensin kaikki aineisto koordinaatteineen sisälle.  
Ay1 ja 2 ovat todellisia havaintoja, periodeittain. Ap1 ja 2 ovat ennusteita.

```{r}
#luetaan sisään reitit, havainnot ja ennusteet
coordinates(Ay1)<-c("x","y")
plot(Ay1)
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
plot(Ay2)
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")
```

Gridit olen tehnyt jo aiemmin QGis:llä. 

```{r}
gridi<- readOGR(dsn="./gridit", layer="grid50km")
#gridi<- readOGR(dsn="./gridit", layer="grid100km")
proj4string(gridi)
```

Itse poolaus tapahtuu niin, että liitetään kuhunkin reittiin tieto, millä gridin ruudulla (id-numero) se on, jonka jälkeen ryhmitellään kaikki reitit gridiruuduittain ja lasketaan niille keskiarvot. Tallennan taas kaikki tiedot niin, että ne on helppo lukea ja tarkistaa GIS:llä.


```{r}
#liiteään kuhunkin reittiin tieto, millä gridin ruudulla se on
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)

#ryhmitelään linjat gridiruuduittain ja lasketaan keskiarvot kullekin sarakkeelle, eli lajeittain.
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #jos jollain lajilla on yhdellä linjalla NA:ta se ei vaikuta keskiarvon laskemiseen. 
  write.csv(.,file = "pool_pa_obs_per1.csv",row.names=F)

#ja sama muille aineistoille
pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_obs_per2.csv",row.names=F)

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per1.csv",row.names=F)

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per2.csv",row.names=F)
```

### Uudet poolatut ennustustarkkuudet, PA

Lopulta lasketaan uudestaan ennustustarkkuudet poolatuilla arvoilla. Toistaiseksi vain metodilla D.

Luetaan aineisto takaisin sisään ja siivotaan sitä hieman:

```{r}
#luetaan aineisto takaisin sisään
paY1<-read.csv("pool_pa_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_pa_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_pa_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_pa_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
names(paY1)
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
```

Lasketaan periodien välinen muutos havainnoille ja ennusteille ja näiden korrelaatiot. (primitiivinen koodaus, voi parannella myöhemmin..)

```{r}
#lasketaan erotukset periodin 1 ja 2 välilä
#pa
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
paKor<-paKor[,keep,drop=F]

#lasketaan korrelaatiot
paKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_pa_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('pa_pool50_results.csv',row.names=F)
```

## Abundance -aineisto

Tehdään sama proseduuri myös abu-aineistolle.

### Aineisto sisälle ja periodien keskiarvojen lasku

```{r}
modeltype = 2 #2 on abu-aineistolle

#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
dim(mpred1)
ns=dim(mpred1)[2]
dim(mpred2)
dim(Y)
dim(studyDesign)

period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

pm1p1=mpred1[period1,]
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2

y1=Y[period1,]
y2=Y[period2,]

sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

# lasketaan kullekin linjalle (jolla on k?yty kahdesti kummankin periodin aikana) keskiarvot periodeittain
#havainnot ja ennusteet erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for(j in 1:ns){
  for (i in 1:nsr){
    take1 = which(sd1$Route == selroutes[i] & y1[,j]>-1) 
    take2 = which(sd2$Route == selroutes[i] & y2[,j]>-1)
    Ap1[i,j] = mean(pm1p1[take1,j]) #ei laske ennusteille keskiarvoa niiltä linjoilta, jotka ovat havainnoissa NA
    Ap2[i,j] = mean(pm1p2[take2,j]) 
    Ay1[i,j] = mean(y1[take1,j], na.rm=T) #NA:t jätetään huomiotta keskiarvoa laskettaessa
    Ay2[i,j] = mean(y2[take2,j], na.rm=T)
  }}
```

### Koordinaattien lisääminen

```{r}
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))

#save observations and predictions for pooling in GIS
write.csv(Ay1,"abu_obs_per1.csv",row.names = F)
write.csv(Ay2,"abu_obs_per2.csv",row.names = F)
write.csv(Ap1,"abu_pred_per1.csv",row.names = F)
write.csv(Ap2,"abu_pred_per2.csv",row.names = F)
```

### Poolaus

```{r}
#luetaan sisään reitit koordinaatteineen
coordinates(Ay1)<-c("x","y")
plot(Ay1)
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
plot(Ay2)
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
plot(Ap1)
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
plot(Ap2)
proj4string(Ap2) <-CRS("+init=EPSG:3035")

#join data based on polygons
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #NA:t eivät vaikuta laskuihin
  write.csv(.,file = "pool_abu_obs_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_obs_per2.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per2.csv",row.names=F,na="")
```

### Uudet poolatut ennustustarkkuudet, ABU


Aineiston siivous:

(Huom! Koodissa olioiden nimissä on hämäävästi 'pa' mutta nämä ovat silti abu-aineistoa.)

```{r}
paY1<-read.csv("pool_abu_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_abu_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_abu_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_abu_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
names(paY1)
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
```

Muutokset periodien välillä ja korrelaatiot:

```{r}
#seuraavaksi lasketaan erotukset periodin 1 ja 2 välilä
#abu
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#pa
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
abuKor<-abuKor[,keep,drop=F]

abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_abu_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('abu_pool50_results.csv',row.names=F)
```


## Poolattujen ennustustarkkuuksien vertailu

Selvitetään, paransiko poolaus ennustustarkkuuksia.

```{r}
#kaikki data sisään
res<-read.csv("results.csv")
pool_pa<-read.csv("pa_pool50_results.csv")
pool_abu<-read.csv("abu_pool50_results.csv")

#100km gridi
#pool_pa<-read.csv("pa_pool100_results.csv")
#pool_abu<-read.csv("abu_pool100_results.csv")

#yhdistely yhdeksi taulukoksi
pool_res<-inner_join(pool_pa,pool_abu,by="Yspecies")
res2<-inner_join(res,pool_res,by=c("species"="Yspecies"))

#tallennetaan omaksi taulukokseen jatkoa varten
write.csv(res2,"results_and_pooled.csv",row.names = F)

##lasketaan kaikille arvoille keskiarvot ja se:t
res2 %>% dplyr::select(2:11)%>%colMeans()
res2 %>% dplyr::select(2:11)%>%std.error()

#muokataan aineistoa
res3=res2[c(1,2,3,4,5,10,6,7,8,9,11)]
res3=gather(res3,"method","accuracy",2:11)
res3$method=as.factor(res3$method)

#plottailua
p=ggplot(res3,aes(x=method,y=accuracy))+geom_boxplot()
p + scale_x_discrete(limits=c("pa_A", "pa_B","pa_C","pa_D","pool_pa_change"))
p+ scale_x_discrete(limits=c("abu_A", "abu_B","abu_C","abu_D","pool_abu_change"))
```

Näyttää siltä, että poolaus on parantanut ennustustarkkuuksia vain hitusen.

Testataan:

```{r}
#valitaan metodi D ja poolatut D arvot
#pa
res4=subset(res3,method=="pool_pa_change"|method=="pa_D")
#testi (two-way anova)
anova(lm(res4$accuracy~res4$species+res4$method))
```

Pa-aineistolla poolaus näyttää parantaneen tilastollisesti merkitsevästi metodi D:n ennustustarkkuutta. Sekä metodien että lajien väliset erot ovat merkitseviä. Huomaa, että 'laji' on vahvempi selittävä muuttuja.

```{r}
#abu
res4=subset(res3,method=="pool_abu_change"|method=="abu_D")
#testi (two-way anova)
anova(lm(res4$accuracy~res4$species+res4$method))
```

Abu-aineistolla poolaus näyttää myös parantaneen ennustustarkkuutta, tosin ei yhtä vahvasti kuin pa-aineistolla. Nyt laji ei ole merkitsevä tekijä eli erot johtuvat vain metodista(?).


Mietin, olenko tehnyt analyysit oikein. Teenkö oikein, jos tulkitsen lajin "samana yksikkönä" eli repeated measurement:nä? Vai olisiko laji pitänyt jättää huomioimatta?

```{r}
#vai pitäisikö tehdä one-way anova?
t.test(res2$pool_pa_change,res2$pa_D, paired = T)
t.test(res2$pool_abu_change,res2$abu_D, paired = T)
```

Tuloksethan ovat samat method-muuuttujalle mutta pitäisikö lajien välisestä vaihtelusta tai sen vähyydestä vetää jotain johtopäätöksiä?


Edelleen mietin, onko järkevää vertailla pa- ja abu-aineistoja, mutta testaanpa nyt kumminkin..

```{r}
#testataan onko merkitsevää eroa
#poolattujen change pa ja abu välillä
res4=subset(res3,method=="pool_abu_change"|method=="pool_pa_change")
anova(lm(res4$accuracy~res4$species+res4$method))

#tai t-testi ilman lajia selittävänä tekijänä
t.test(res2$pool_pa_change,res2$pool_abu_change, paired=TRUE)
```

Aineistojen välillä ei löydy merkitseviä eroja kun tarkastellaan poolattuja ennustustarkkuuksia. 

### Kuvaaja

```{r, fig.width=14, fig.height=12}
#piirretään sama kuvaaja, jossa nyt mukana myös poolatut arvot

#määritetään kuvalle raamit ja nimi
Line=c(-1,1)
Line2=c(-1,1)
Line3=c(0,0)

Line=cbind(Line,Line2)
Line=cbind(Line,Line3)

Line=as.data.frame(Line)

#pdf("Pooled_Fig1.pdf")

#määrittää 3x3 matriisin johon kuvat piirretään
layout(matrix(c(1,2,7,3,4,7,5,6,7), 3, 3, byrow = TRUE))

# a)
plot(pa_B~pa_A,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (A)",
     ylab="Prediction accuracy (B)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"a) Distribution",cex=0.8)


# b)
plot(abu_B~abu_A,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (A)",
     ylab="Prediction accuracy (B)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"b) Abundance",cex=0.8)

# c)
plot(pa_D~pa_C,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (C)",
     ylab="Prediction accuracy (D)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"c) Distribution, 2 km",cex=0.8)

# d)
plot(abu_D~abu_C,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (C)",
     ylab="Prediction accuracy (D)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"d) Abundance, 2 km",cex=0.8)

# e) 
plot(pool_pa_change~pa_D,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (D)",
     ylab="Pooled prediction accuracy (change)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"e) Distribution, 50 km",cex=0.8)

# f)
plot(pool_abu_change~abu_D,data=res2,xlim=c(-1,1),
     ylim=c(-1,1),cex.axis=0.8,xlab="Prediction accuracy (D)",
     ylab="Pooled prediction accuracy (change)")
lines(Line$Line,Line$Line2,lty="dashed")
lines(Line$Line,Line$Line3,col="grey",lty="dashed")
lines(Line$Line3,Line$Line,col="grey",lty="dashed")

text(-0.5,0.8,"f) Abundance, 50km", cex=0.8)

#dev.off()
```


Tässäkin täytyy varmaan vielä miettiä, mitä halutaan esittää kuvaajissa. Aikaisemmin verrattiin uutta validointimenetelmää D (ja uusia poolattuja arvoja) vanhaan menetelmään, joka edusti ennustustarkkuutta kun mallin validoinnissa käytettiin samoja havaintoja kuin mallin kalibroinnissa (_past oli melkein vastaava kuin metodi A). 

