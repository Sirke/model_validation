---
title: "part4"
author: "me"
date: "12 joulukuuta 2019"
output: html_document
---

# 4. Traits analyysi

Selvitetään ovatko tietyt lajiominaisuudet kytköksissä ennustustarkkuuteen.  
Analysoin pa ja abu-aineistot erillään. Edellisissä analyyseissahan aineistot on analysoitu yhdessä (metodin ja aineistotyypin (pa/abu) interaktio). Meneekö tämä siis oikein?

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

getwd()
paketit<-c("visreg","nlme","readr","tidyr","dplyr","plyr","magrittr","purrr","ggplot2","ape","geiger","MuMIn","psych","Hmisc")
lapply(paketit,library,character.only=T)
```

## 4.1 Aineisto sisään ja taulukoiden kokoaminen

Valitsen tarkasteluun vain poolatut ennustustarkkuudet. Järjestelen aineiston eri tavalla (vanhaan koodiin sopivaksi).

```{r }
#aineiston valinta, leväyttäminen ja uudelleen nimeäminen
res<-read.csv("results_and_pooled.csv")
res2=subset(res,method=="pool_D")
res3=spread(res2,pa,accuracy)
res3$method=NULL
res4=res3 %>% dplyr::rename(pool_pa_change = pa, pool_abu_change = abu)

#lisätään lajiominaisuudet taulukkoon
traits<-read.csv("traits_table.csv",sep = ";")
results<-inner_join(res4,traits,by="species")
str(results)

#uusi muuttuja, massan logaritmi
results$logmass<-log(results$Mass)

#uusi muuttuja, log-muunnettu prevalenssi
results$PrevS=log(results$Prev)

#arcsin-muunnos (kokeiltu)
#asinTransform <- function(p) { asin(sqrt(p)) }
#results$PrevS=asinTransform(results$Prev)

#logit-muunnos (kokeilin, antaa ihan samanlaiset residuaalit)
#logitTransform <- function(p) { log(p/(1-p)) }
#results$PrevS=logitTransform(results$Prev)

#tallenna tarvittaessa omaksi taulukokseen
#write.csv(results,"accuracies_traits.csv",row.names = F)
```

## 4.2 Aineiston tarkastelu

Tarkastellaan aineistoa kuvaajista.

Poolattu 50 x 50 km aineisto, pa ja abu:

```{r }
#poolattu pa aineisto
op<-par(mfrow=c(2,2),mar=c(5,4,1,2))
boxplot(pool_pa_change~Hab,data=results,ylab="pool_pa_D",xlab="Habitat")
plot(pool_pa_change~Prev, data = results,ylab="pool_pa_D",xlab="Prevalence")
abline(lm(pool_pa_change~Prev,data = results))
boxplot(pool_pa_change~Mig,data=results,ylab="pool_pa_D",xlab="Migration")
plot(pool_pa_change~Mass, data = results,ylab="pool_pa_D",xlab="Mass")
abline(lm(pool_pa_change~Mass,data = results))
par(op)

#poolattu abu aineisto
op<-par(mfrow=c(2,2),mar=c(5,4,1,2))
boxplot(pool_abu_change~Hab,data=results,ylab="pool_abu_D",xlab="Habitat")
plot(pool_abu_change~Prev, data = results,ylab="pool_abu_D",xlab="Prevalence")
abline(lm(pool_abu_change~Prev,data = results))
boxplot(pool_abu_change~Mig,data=results,ylab="pool_abu_D",xlab="Migration")
plot(pool_abu_change~Mass, data = results,ylab="pool_abu_D",xlab="Mass")
abline(lm(pool_abu_change~Mass,data = results))
par(op)

ggplot(results,aes(x=Prev,y=pool_abu_change))+geom_point(aes(colour = factor(Hab)))

ggplot(results,aes(x=Mass,y=pool_abu_change))+geom_point(aes(colour = factor(Mig)))
```

Prevalenssilla näyttäisi olevan jonkinlainen suhde ennustustarkkuuteen. Ainakin se on kummallakin aineistolla niukasti positiivisesti korreloitunut.

Ennustustarkkuus vaihtelee suuresti harvinaisemmille lajeille verrattuna yleisempiin lajeihin. Vesi- ja suo- ja tunturilajit tuppaavat olemaan harvinaisempia ja niillä suurempaa vaihtelua ennustustarkkuudessa.

Pitkän matkan muuttajissa näyttää korostuvan pienet lajit. Pienillä lajeilla enemmän vaihtelua ennustustarkkuudessa.


```{r}
pairs(results[8:9])
cor(results$Mass,results$PrevS)
```

Massa ja yleisyys eivät näytä korreloivan. 


## 4.3 Fylogenia

BirdTree.org palvelusta on haettu lintujen sukupuu (tai itseasiassa tiedosto sisältää 100 vaihtoehtoista sukupuuta, joista valitaan yksi). 

```{r }
#luetaan aineisto sisään, Multiphylo eli monta puuta
linnut <- read.nexus("output.nex")
#valitaan vain yksi puu, mikä tahansa sadasta
linnut2<-linnut[[99]]
#define a variance-covariance structure based on the model of Brownian evolution
bm.birds=corBrownian(1,phy=linnut2)
#tehdään fylogenialistasta matriisi
lintupuu<-vcv.phylo(linnut2)
#matriisin voi värittää havainnollistamaan lintulajien sukulaisuutta
heatmap(lintupuu,Rowv = NA,Colv = NA)

#abu-aineistoa varten pari lajia pois, muuten koodi ei toimi
linnut3=drop.tip(linnut2, "Emberiza_rustica", trim.internal = TRUE, subtree = FALSE,
         root.edge = 0, rooted = is.rooted(linnut2), collapse.singles = TRUE,
         interactive = FALSE)
linnut4=drop.tip(linnut3, "Bonasa_bonasia", trim.internal = TRUE, subtree = FALSE,
         root.edge = 0, rooted = is.rooted(linnut2), collapse.singles = TRUE,
         interactive = FALSE)
bm.birds2=corBrownian(1,phy=linnut4)

#aineiston rivien nimet muutetaan lattareiksi jolloin keskustelee fylogeniapuun kanssa
rownames(results)=results$species
```

"The so called **Brownian motion** (also called random walk or diffusion)
3191 model of trait evolution, which is the simplest model among the many alternative models of how
3192 traits might evolve (Beaulieu et al., 2012)."


## 4.4 Analyysit

Selvitetään, vaikuttavatko lajien ominaisuudet (muuttokäyttäytyminen 'Mig', elinympäristö 'Hab', paino 'logMass' tai prevalenssi 'Prev') ennustustarkkuuteen. Analyysissä pitäisi huomioida fylogenia eli, että lajit voivat olla ominaisuuksiltaan samankaltaisia (ja siten omata myös samanlaiset ennustustarkkuudet) läheisen sukulaisuussuhteen takia. 

### 4.4.1 Pa-aineisto

Luodaan kaikki mahdolliset mallivaihtoehdot, 16 kpl.

```{r }
#luodaan eri mallivaihtoehtoja
malli0 <- gls(pool_pa_change ~ 1, data = results,correlation=bm.birds,method="ML")
malli1 <- gls(pool_pa_change ~ Mig, data = results,correlation=bm.birds,method="ML")
malli2 <- gls(pool_pa_change ~ Hab, data = results,correlation=bm.birds,method="ML")
malli3 <- gls(pool_pa_change ~ log(Mass), data = results,correlation=bm.birds,method="ML")
malli4 <- gls(pool_pa_change ~ Prev, data = results,correlation=bm.birds,method="ML")
malli5 <- gls(pool_pa_change ~ Mig + Hab, data = results,correlation=bm.birds,method="ML")
malli6 <- gls(pool_pa_change ~ Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli7 <- gls(pool_pa_change ~ Mig + log(Mass), data = results,correlation=bm.birds,method="ML")
malli8 <- gls(pool_pa_change ~ log(Mass)+Prev, data = results,correlation=bm.birds,method="ML")
malli9 <- gls(pool_pa_change ~ Mig +Prev, data = results,correlation=bm.birds,method="ML")
malli10 <- gls(pool_pa_change ~ Hab+Prev, data = results,correlation=bm.birds,method="ML")
malli11 <- gls(pool_pa_change ~ Mig + Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli12 <- gls(pool_pa_change ~ Mig + Hab + Prev, data = results,correlation=bm.birds,method="ML")
malli13 <- gls(pool_pa_change ~ Mig + Prev + log(Mass), data = results,correlation=bm.birds,method="ML")
malli14 <- gls(pool_pa_change ~ Prev + Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli15 <- gls(pool_pa_change ~ Mig + Hab + log(Mass)+Prev, data = results,correlation=bm.birds,method="ML")

#mallin valintaa MuMin paketin avulla
output1<-model.sel(malli0,malli1,malli2,malli3,malli4,malli5,malli6,malli7,malli8,malli9,malli10,malli11,malli12,malli13,malli14,malli15) 

# AICc Table
output1
```

Mallit 3, 0, 8 ja 4 ovat neljän AICc yksikön päässä toisistaan.    
Valitaan ne jatkoon ja tehdään model averaging.

Tai sitten kahden AICc yksikön sisällä on vain kaksi mallia -> valitaan niistä yksinkertaisempi  -> malli0

Mallinvalinnasta AIC-arvojen avulla voi lukea [täältä](http://webhome.auburn.edu/~tds0009/PDFs/arnold%20et%20al.%202010.pdf). Tosin tämän artikkelin mukaan olisin ehkä ennemmin vertaillut weights-arvoja. Lainaus: "If the primary objective of modeling is to evaluate the relative importance of many potential predictor variables, such as in many habitat selection
studies, then summing Akaike model weights across all models that include that variable can be a useful approach."

```{r }
#tehdään model averaging
topmodels = get.models(output1,subset=delta<4)
#topmodels<-model.sel(malli0,malli3,malli8,malli4)
summary(model.avg(topmodels, revised.var = TRUE))
```

Mikään ei näytä selittävän ennustustarkkuutta. Full-average arvot kaikille muuttujille ovat ei-merkitseviä.

```{r }
# sovitetaan malli uudestaan REML asetuksilla
malli0 <- gls(pool_pa_change ~ 1, data = results,correlation=bm.birds,method="REML")

summary(malli0)

op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(malli0,add.smooth = F,which =1)
E<-resid(malli0)
hist(E, xlab = "residuals",main = "")
plot(results$Prev,E,xlab = "prevalence",ylab="residuals")
plot(results$Hab,E,xlab = "habitat",ylab="residuals")
plot(results$Mig,E,xlab = "migration",ylab="residuals")
plot(results$logmass,E,xlab = "logMass",ylab="residuals")
par(op)
```

En tiedä, onko mitään järkeä tuijotella nollamallin residuaaleja mutta siinä ne nyt ovat. Ei kai noissa mitään hälyyttäviä kuvioita ole. Yleisesti residuaalit ovat enemmän positiivisen puolella.  

Eli pa-aineistolla mikään lajiominaisuus ei selitä ennustustarkkuutta.

**Huom!** Otson koodissa fylogenia rakennetaan "corPagel" asetuksilla. Tällä ei kai käytännössä kuitenkaan ole suurta eroa corBrownian-asetukseen.

**Huom!** Mallien sovittaminen REML-asetuksilla ei aiheuta muutosta tuloksiin. Nollamalli oli entistä selvemmällä erolla parhain malli. Päädyttiin siihen, että mallin valinta tulisi tehdä kuitenkin ML-asetuksella.

### 4.4.2 Abu-aineistolle

Abu-aineistossa on muutama NA-havainto, joka monimutkaistaa koodaamista. Gls-mallit toimivat kyllä NA-havaintojenkin kanssa (na.action="na.omit", huom: "na.exclude" ei toimi tässä) mutta fylogenia puu sisältää kaksi lajia liikaa (pohjansirkku ja pyy). Fylogenia puuta on siis muokattava. Edit: Tein tämän jo koodin alussa. Näissä malleissa käytetään siis fylogeniana 'bm.birds2'-fylogeniaa, jossa vain 118 lajia.


```{r }
#luodaan eri mallivaihtoehtoja
malli0 <- gls(pool_abu_change ~ 1, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli1 <- gls(pool_abu_change ~ Mig, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli2 <- gls(pool_abu_change ~ Hab, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli3 <- gls(pool_abu_change ~ logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli4 <- gls(pool_abu_change ~ Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli5 <- gls(pool_abu_change ~ Mig + Hab, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli6 <- gls(pool_abu_change ~ Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli7 <- gls(pool_abu_change ~ Mig + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli8 <- gls(pool_abu_change ~ logmass + Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli9 <- gls(pool_abu_change ~ Mig + Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli10 <- gls(pool_abu_change ~ Hab + Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli11 <- gls(pool_abu_change ~ Mig + Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli12 <- gls(pool_abu_change ~ Mig + Hab + Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli13 <- gls(pool_abu_change ~ Mig + Prev + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli14 <- gls(pool_abu_change ~ Prev + Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli15 <- gls(pool_abu_change ~ Mig + Hab + logmass+Prev, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")

#mallin valintaa MuMin paketin avulla
output1<-model.sel(malli0,malli1,malli2,malli3,malli4,malli5,malli6,malli7,malli8,malli9,malli10,malli11,malli12,malli13,malli14,malli15) 

# AICc Table
output1
```

Mallit 10, 8, 14, 4 ovat neljän yksikön marginaalissa.

(Tai, kahden AICc yksikön sisään mahtuu malli 10 ja 14, joista vasta toiseksi paras 10 on yksinkertaisempi.)

```{r }
#tehdään model averaging
topmodels = get.models(output1,subset=delta<4)
#topmodels<-model.sel(malli8,malli13,malli14)
summary(model.avg(topmodels, revised.var = TRUE))
```

Pelkkä prevalenssi merkitsevä full-average vertailussa. Eli yksinkertaisin malli4 näyttäisi sisältävän tarvittavat selittävät tekijät. 

```{r }
#sovitetaan malli uudestaan REML asetuksilla
malli_final <- gls(pool_abu_change ~ Prev, data = results,correlation=bm.birds2,method="REML",na.action="na.omit")

summary(malli_final)
```

Mitäpä tästä mallista nyt sanoisi? Selittääkö se mitään vai ei?

Mallin validointi:

```{r }
#plottaus ei toimi jos aineistoissa on eri määrä havaintoja
results2=subset(results,species!="Emberiza_rustica" & species!="Bonasa_bonasia")

#seuraavaksi mallin validointia kuvaajista
op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(malli_final)
E<-resid(malli_final)
hist(E, xlab = "residuals",main = "")
plot(results2$Prev,E,xlab = "prevalence",ylab="residuals")
plot(results2$Hab,E,xlab = "habitat",ylab="residuals")
plot(results2$Mig,E,xlab = "migration",ylab="residuals")
plot(results2$logmass,E,xlab = "logMass",ylab="residuals")
par(op)

qqnorm(E)
qqline(E)
```

Prevalenssin residuaalit eivät ole tasaisesti jakautuneita (massassakin näkyy jonkinlainen trendi). Pienillä arvoilla ennustustarkkuuksissa on enemmän vaihtelua. Voiko tämä johtua siitä, että tutkituista lajeista suurin osa nyt vaan sattuu olemaan harvinaisempia? Ja koska harvinaisempia lajeja on aineistossa enemmän niin sen myötä myös erilaisia (isoja ja pieniä) ennustustarkkuuksiakin on enemmän? Mutta tuleeko tässä rikkoneeksi lineaarisen mallin oletusta yhtenäisestä varianssista? 

Residuaalien ja sovitettujen arvojen tulkinnasta lisää [täällä](https://online.stat.psu.edu/stat462/node/120/).


### 4.4.3 Muunnoksien testailua

Testataan muuntaa Prev vaikkapa log-muunnoksella. Tämä on tehty jo koodin alussa. Loin muuttujan 'PrevS'. Muunnosta voi käydä vaihtamassa koodin alussa. Muita testaamiani muunnoksia olivat logit ja arcsin. Ohjeet löysin [täältä](http://strata.uga.edu/8370/rtips/proportions.html).

Testataan muunnoksen vaikutusta kummallakin aineistotyypillä.

```{r }
#pa-aineisto
malli0 <- gls(pool_pa_change ~ 1, data = results,correlation=bm.birds,method="ML")
malli1 <- gls(pool_pa_change ~ Mig, data = results,correlation=bm.birds,method="ML")
malli2 <- gls(pool_pa_change ~ Hab, data = results,correlation=bm.birds,method="ML")
malli3 <- gls(pool_pa_change ~ log(Mass), data = results,correlation=bm.birds,method="ML")
malli4 <- gls(pool_pa_change ~ PrevS, data = results,correlation=bm.birds,method="ML")
malli5 <- gls(pool_pa_change ~ Mig + Hab, data = results,correlation=bm.birds,method="ML")
malli6 <- gls(pool_pa_change ~ Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli7 <- gls(pool_pa_change ~ Mig + log(Mass), data = results,correlation=bm.birds,method="ML")
malli8 <- gls(pool_pa_change ~ log(Mass)+PrevS, data = results,correlation=bm.birds,method="ML")
malli9 <- gls(pool_pa_change ~ Mig +PrevS, data = results,correlation=bm.birds,method="ML")
malli10 <- gls(pool_pa_change ~ Hab+PrevS, data = results,correlation=bm.birds,method="ML")
malli11 <- gls(pool_pa_change ~ Mig + Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli12 <- gls(pool_pa_change ~ Mig + Hab + PrevS, data = results,correlation=bm.birds,method="ML")
malli13 <- gls(pool_pa_change ~ Mig + PrevS + log(Mass), data = results,correlation=bm.birds,method="ML")
malli14 <- gls(pool_pa_change ~ PrevS + Hab + log(Mass), data = results,correlation=bm.birds,method="ML")
malli15 <- gls(pool_pa_change ~ Mig + Hab + log(Mass)+PrevS, data = results,correlation=bm.birds,method="ML")

#mallin valintaa MuMin paketin avulla
output1<-model.sel(malli0,malli1,malli2,malli3,malli4,malli5,malli6,malli7,malli8,malli9,malli10,malli11,malli12,malli13,malli14,malli15) 

# AICc Table
output1

#taulukko wordiin
write.table(output1, "model_selection_table_pa.csv")
```

Sama tulos. Kun katsotaan parhaat AIC < 2 mallit, paras malli ei ole yksinkertaisin. Siksi laajennetaan AIC < 4 ja tehdään model averaging. 

```{r }
#tehdään model averaging
topmodels = get.models(output1,subset=delta<4)
#output2<-model.sel(malli0,malli3,malli8,malli4)


summary(model.avg(topmodels, revised.var = TRUE))

#sama hieman eri koodilla
#summary(model.avg(output1, subset=delta<4))

#luottamusvälit
confint(model.avg(topmodels, subset=delta<4))
```
 
Sama tulos. Mikään tekijä ei selitä ennustustarkkuutta.

Selvensin itselleni mitä tuo argumentti *revised.var* oikein tekee. Se laskee standard errorit jollain päivitetyllä kaavalla. "Unconditional standard errors are square root of the variance estimator, calculated either according to the original equation in Burnham and Anderson (2002, equation 4.7), or a newer, revised formula from Burnham and Anderson (2004, equation 4) (if revised.var = TRUE, this is the default)."

Kokeilin myös hakea muuttujille luottamusvälit.

Mallin validointi niin, että validoidaan AICc-vertailun mukaan paras malli.

```{r }
# sovitetaan malli uudestaan REML asetuksilla
malli_final <- gls(pool_pa_change ~ log(Mass) + PrevS, data = results,correlation=bm.birds,method="REML")

summary(malli_final)

op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(malli_final,add.smooth = F,which =1)
E<-resid(malli_final)
hist(E, xlab = "residuals",main = "")
plot(results$PrevS,E,xlab = "prevalence",ylab="residuals")
plot(results$Hab,E,xlab = "habitat",ylab="residuals")
plot(results$Mig,E,xlab = "migration",ylab="residuals")
plot(results$logmass,E,xlab = "logMass",ylab="residuals")
par(op)
```

Ainakin prevalenssin residuaalit näyttävät ihan ok:lta. Mutta pa-aineistolla residuaalien kanssa ei niin ongelmia ollutkaan.

 
Sama abundance-aineistolle:
 
```{r }
#abu-aineisto

#luodaan eri mallivaihtoehtoja
malli0 <- gls(pool_abu_change ~ 1, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli1 <- gls(pool_abu_change ~ Mig, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli2 <- gls(pool_abu_change ~ Hab, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli3 <- gls(pool_abu_change ~ logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli4 <- gls(pool_abu_change ~ PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli5 <- gls(pool_abu_change ~ Mig + Hab, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli6 <- gls(pool_abu_change ~ Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli7 <- gls(pool_abu_change ~ Mig + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli8 <- gls(pool_abu_change ~ logmass+PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli9 <- gls(pool_abu_change ~ Mig +PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli10 <- gls(pool_abu_change ~ Hab+PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli11 <- gls(pool_abu_change ~ Mig + Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli12 <- gls(pool_abu_change ~ Mig + Hab + PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli13 <- gls(pool_abu_change ~ Mig + PrevS + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli14 <- gls(pool_abu_change ~ PrevS + Hab + logmass, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli15 <- gls(pool_abu_change ~ Mig + Hab + logmass+PrevS, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")

#mallin valintaa MuMin paketin avulla
output1<-model.sel(malli0,malli1,malli2,malli3,malli4,malli5,malli6,malli7,malli8,malli9,malli10,malli11,malli12,malli13,malli14,malli15) 

# AICc Table
output1

#taulukko wordiin
write.table(output1, "model_selection_table_abu.csv")
```

Sama tulos. 

```{r }
#tehdään model averaging
topmodels = get.models(output1,subset=delta<4)
#output2<-model.sel(malli0,malli3,malli8,malli4)

summary(model.avg(topmodels, revised.var = TRUE))

#sama hieman eri koodilla
#summary(model.avg(output1, subset=delta<4))

#luottamusvälit
confint(model.avg(topmodels, subset=delta<4))
```

Sama tulos. Pelkkä prevalenssi. Eihän habitaatti ole tässä merkitsevä, vaikka sen luottamusvälit negatiivisena koko ajan pysyvätkin?


```{r }
#sovitetaan malli uudestaan REML asetuksilla
malli_final <- gls(pool_abu_change ~ PrevS + Hab + logmass, data = results,correlation=bm.birds2,method="REML",na.action="na.omit")
summary(malli_final)
```

Seuraavaksi yritän käyttää visreg-funktiota mallin visualisointiin. Sovitan mallin uudestaan niin, että log-muunnokset tehdään itse mallissa. Näin visreg osaa automaattisesti takaisinmuuntaa muuttujat.

Mitenköhän visreg toimii model averaged tuloksille? Tätä pohdin peltosirkkutyössäkin. Miten validoida model averaged tulokset kun eihän siitä tule tulokseksi yhtä mallia suoraan vaan arviot estimaateille. 

```{r}
#malli uudestaan
model <- gls(pool_abu_change ~ log(Prev) + Hab + log(Mass), data = results,correlation=bm.birds2,method="REML",na.action="na.omit")

summary(model)

visreg(model, "Prev")
#onhan tämä varmasti oikein? Miksi y-akselilla on f(Prev) eikä pool_abu_change? En keksi miksi.

#sama mutta muutan labelit. Poistamalla sulun ja #:n kuvaajaan saa myös smootherin
visreg(model, "Prev",ylab="Prediction accuracy",xlab="Prevalence") #,gg=TRUE)+theme_bw() + geom_smooth(method="loess", col='#FF4E37', fill='#FF4E37')

#visreg(model, "logmass",ylab="Prediction accuracy",xlab="log(Mass)") #,gg=TRUE)+theme_bw() + geom_smooth(method="loess", col='#FF4E37', fill='#FF4E37')

#selittävät muuttujat voisivat olla samassa kuvaajassakin
#mutta silloin tässä ei näy nuo residuaalit
#visreg2d(model, x="Prev", y="logmass", plot.type="image")

```

Mustavalkoinen versio:

```{r}
visreg(model, "Prev",ylab="Prediction accuracy",xlab="log(Prevalence)",fill=list(col=grey(c(0.7), alpha=0.4)),
       line=list(lty=1, col="black"),points=list(cex=1))
```




Mallin validointi perustuen AICc-vertailun parhaimpaan malliin:

```{r }
#plottaus ei toimi jos aineistoissa on eri määrä havaintoja
results2=subset(results,species!="Emberiza_rustica" & species!="Bonasa_bonasia")

#seuraavaksi mallin validointia kuvaajista
op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(malli_final)
E<-resid(malli_final)
hist(E, xlab = "residuals",main = "")
plot(results2$PrevS,E,xlab = "logPrevalence",ylab="residuals")
plot(results2$Hab,E,xlab = "habitat",ylab="residuals")
plot(results2$Mig,E,xlab = "migration",ylab="residuals")
plot(results2$logmass,E,xlab = "logMass",ylab="residuals")
par(op)

qqnorm(E)
qqline(E)
```

Prevalenssin residuaalit ehkä tasaisemmin jakautuneet. Ollaanko tähän tyytyväisiä?


### 4.4.4 Testailua erilaisilla varianssirakenteilla

Kokeilin abu-aineiston analyysissa erilaisia varianssirakennevaihtoehtoja:  
Tässä asetus pitää olla REML, ikäänkuin testattaisiin erilaisia random-rakenteita.

```{r}
Fo=formula(pool_abu_change ~ Mig + Hab + logmass + Prev) #tässä pitäisi olla mukana kaikki mahdolliset interaktiotkin mutta malli ei silloin toimi

#aloitetaan perus lineaarisella mallilla
m.gls1 <- gls(Fo, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")
summary(m.gls1)

op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(m.gls1,add.smooth = F,which =1)
E<-resid(m.gls1)
hist(E, xlab = "residuals",main = "")
plot(results2$Prev,E,xlab = "prevalence",ylab="residuals")
plot(results2$Hab,E,xlab = "habitat",ylab="residuals")
plot(results2$Mig,E,xlab = "migration",ylab="residuals")
plot(results2$logmass,E,xlab = "logMass",ylab="residuals")
par(op)

#tehdään malleja, joissa on erilaisia varianssirakenteita
vf2<-varExp(form=~Prev)
m.gls2 <- gls(Fo, weights=vf2, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

vf3<-varExp(form=~logmass)
m.gls3 <- gls(Fo, weights=vf3, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

vf4<-varIdent(form=~1|Hab)
m.gls4 <- gls(Fo, weights=vf4, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

vf5<-varIdent(form=~1|Mig)
m.gls5 <- gls(Fo, weights=vf5, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

vf6<-varIdent(form=~1|Mig*Hab)
m.gls6 <- gls(Fo, weights=vf6, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

vf7<-varComb(varIdent(form=~1|Mig),varExp(form=~Prev))
m.gls7 <- gls(Fo, weights=vf7, data = results, correlation=bm.birds2, method="REML", na.action="na.omit")

#verrataan kaikkia malleja
AIC(m.gls1,m.gls2,m.gls3,m.gls4,m.gls5,m.gls6,m.gls7)
```

Malli, jossa prevalenssille ja muuttokäyttäytymiselle suodaan enemmän vaihtelua on näistä parhain. Eli m.gls7.

Katsotaan kuvaajista tämän mallin residuaalit:

```{r}
op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(m.gls7,add.smooth = F,which =1)
E<-resid(m.gls7,type="normalized")    #huom! tässä oltava normalized residuaalit
hist(E, xlab = "residuals",main = "")
plot(results2$Prev,E,xlab = "prevalence",ylab="residuals")
plot(results2$Hab,E,xlab = "habitat",ylab="residuals")
plot(results2$Mig,E,xlab = "migration",ylab="residuals")
plot(results2$logmass,E,xlab = "logMass",ylab="residuals")
par(op)
```

Nämä residuaalit näyttävät paremmilta(?)

Sitten valitaan paras fixed osa:  
Tässä asetus pitää olla ML. 

```{r }
#luodaan eri mallivaihtoehtoja
malli0 <- gls(pool_abu_change ~ 1, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli1 <- gls(pool_abu_change ~ Mig, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli2 <- gls(pool_abu_change ~ Hab, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli3 <- gls(pool_abu_change ~ logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli4 <- gls(pool_abu_change ~ Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli5 <- gls(pool_abu_change ~ Mig + Hab, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli6 <- gls(pool_abu_change ~ Hab + logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli7 <- gls(pool_abu_change ~ Mig + logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli8 <- gls(pool_abu_change ~ logmass+Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli9 <- gls(pool_abu_change ~ Mig +Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli10 <- gls(pool_abu_change ~ Hab+Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli11 <- gls(pool_abu_change ~ Mig + Hab + logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli12 <- gls(pool_abu_change ~ Mig + Hab + Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli13 <- gls(pool_abu_change ~ Mig + Prev + logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli14 <- gls(pool_abu_change ~ Prev + Hab + logmass, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")
malli15 <- gls(pool_abu_change ~ Mig + Hab + logmass+Prev, weights=vf7, data = results,correlation=bm.birds2,method="ML",na.action="na.omit")

#mallin valintaa MuMin paketin avulla
output1<-model.sel(malli0,malli1,malli2,malli3,malli4,malli5,malli6,malli7,malli8,malli9,malli10,malli11,malli12,malli13,malli14,malli15) 

# AICc Table
output1

summary(malli1)
```

Nyt Mig nousee selittäväksi tekijäksi.  

Sovitetaan malli vielä kerran REML asetuksilla ja tarkistetaan residuaaleista mallin pätevyys.

```{r}
malli1A <- gls(pool_abu_change ~ Mig, weights=vf7, data = results,correlation=bm.birds2,method="REML",na.action="na.omit")
anova(malli1A)

#seuraavaksi mallin validointia kuvaajista
op<-par(mfrow=c(2,3),mar=c(5,4,1,2))
plot(malli1A,add.smooth = F,which =1)
E<-resid(malli1A,type="normalized")    #huom! tässä oltava normalized residuaalit
hist(E, xlab = "residuals",main = "")
plot(results2$Prev,E,xlab = "prevalence",ylab="residuals")
plot(results2$Hab,E,xlab = "habitat",ylab="residuals")
plot(results2$Mig,E,xlab = "migration",ylab="residuals")
plot(results2$logmass,E,xlab = "logMass",ylab="residuals")
par(op)
```


Nämä residuaalit näyttävät mielestäni paremmilta kuin alkuperäiset mutta en tiedä onko varianssien sörkkiminen kuinka järkevää. Toisaalta habitaatin residuaalit ovat nyt vastaavasti enemmän pielessä.

### kokeillaan muillekin metodeille


```{r eval=FALSE, include=FALSE}
#aineiston valinta, leväyttäminen ja uudelleen nimeäminen
res<-read.csv("results_and_pooled.csv")
res=res[,c(1,4,2,3)]

res %>% 
  gather(variable, value, -(pa:method)) %>%
  unite(temp, method, variable) %>%
  spread(temp, value)

res$method=NULL
res4=res3 %>% dplyr::rename(pool_pa_change = pa, pool_abu_change = abu)

#lisätään lajiominaisuudet taulukkoon
traits<-read.csv("traits_table.csv",sep = ";")
results<-inner_join(res4,traits,by="species")
str(results)

#uusi muuttuja, massan logaritmi
results$logmass<-log(results$Mass)

#uusi muuttuja, log-muunnettu prevalenssi
results$PrevS=log(results$Prev)

```