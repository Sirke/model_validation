anova(A1,A2)
AIC(A1,A2)
A1=gls(accuracy ~ method*pa, method="REML", data=res2,na.action="na.exclude")
A2=lme(accuracy ~ method*pa, random=~1|species, data=res2,method="REML",na.action="na.exclude")
#tai eri funktiolla (lme4)
#A2b=lmer(accuracy ~ method*pa + (1|species), data=res2,REML = T,na.action="na.exclude")
anova(A1,A2)
AIC(A1,A2)
summary(A2)
#muita vaihtoehtoja random-rakenteen testaamiseksi:
A3=lmer(accuracy ~ method + (1+method|species), data=res2,REML = T,na.action="na.exclude")
A4=lmer(accuracy ~ method + (1+method|species)+(1|pa), data=res2,REML = T,na.action="na.exclude")
A2full=lme(accuracy~method*pa,data=res2,random=~1|species,method="ML",na.action="na.exclude")
A2.a=lme(accuracy~method+pa,data=res2,random=~1|species,method="ML",na.action="na.exclude")
A2.b=lme(accuracy~method,data=res2,random=~1|species,method="ML",na.action="na.exclude")
A2.c=lme(accuracy~pa,data=res2,random=~1|species,method="ML",na.action="na.exclude")
A2.d=lme(accuracy ~ 1, random=~1|species, data=res2,method="ML",na.action="na.exclude")
anova(A2full,A2.a)
anova(A2full)
AIC(A2full,A2.a,A2.b,A2.c,A2.d)
A2full=lme(accuracy~method*pa,data=res2,random=~1|species,method="REML",na.action="na.exclude")
summary(A2full)
plot(A2full)
qqnorm(A2full)
qqnorm(A2full,~ranef(.),col=1)
intervals(A2full)
E1=rstandard(A2full)
E1=resid(A2full, type="normalized")
F1=fitted(A2full)
par(mfrow=c(2,2), mar=c(5,5,2,2))
plot(x=F1,y=E1,xlab="fitted",ylab="residuals",data=res2)
abline(h=0,lty=2)
abline(h=0,lty=2)
boxplot(E1~pa,xlab="pa",ylab="residuals",data=res2)
E1=resid(A2full, type="normalized")
F1=fitted(A2full)
par(mfrow=c(2,2), mar=c(5,5,2,2))
plot(x=F1,y=E1,xlab="fitted",ylab="residuals",data=res2)
abline(h=0,lty=2)
boxplot(E1~method,xlab="method",ylab="residuals",data=res2)
abline(h=0,lty=2)
boxplot(E1~pa,xlab="pa",ylab="residuals",data=res2)
abline(h=0,lty=2)
par(mfrow=c(1,1), mar=c(5,5,2,2))
boxplot(E1~species,xlab="species",ylab="residuals",data=res2)
abline(h=0,lty=2)
plot(A2full)
qqnorm(A2full)
qqnorm(A2full,~ranef(.),col=1)
intervals(A2full)
A2full=lme(accuracy~method*pa,data=res2,random=~1|species,method="REML",na.action="na.exclude")
summary(A2full)
#stats
res2 %>%
group_by(method,pa)%>%
get_summary_stats(accuracy, type = "mean_sd")
#visualization
bxp <- ggboxplot(
res2, x = "method", y = "accuracy",
color = "pa", palette = "jco"
)
bxp
#outliers
res2 %>%
group_by(method,pa) %>%
identify_outliers(accuracy)
#normality
res2 %>%
group_by(method,pa) %>%
shapiro_test(accuracy)
#qqplot
ggqqplot(res2, "accuracy", ggtheme = theme_bw()) +
facet_grid(method ~ pa, labeller = "label_both")
#the test
res.aov <- anova_test(
data = res2, dv = accuracy, wid = species,
within = c(pa, method)
)
get_anova_table(res.aov)
# Effect of pa at each method
one.way <- res2 %>%
group_by(method) %>%
anova_test(dv = accuracy, wid = species, within = pa) %>%
get_anova_table() %>%
adjust_pvalue(method = "bonferroni")
one.way
# Effect of method at both data types
one.way <- res2 %>%
group_by(pa) %>%
anova_test(dv = accuracy, wid = species, within = method) %>%
get_anova_table() %>%
adjust_pvalue(method = "bonferroni")
one.way
# Pairwise comparisons between data types
pwc <- res2 %>%
group_by(method) %>%
pairwise_t_test(
accuracy ~ pa, paired = TRUE,
p.adjust.method = "bonferroni"
)
pwc
# Pairwise comparisons between methods
pwc <- res2 %>%
group_by(pa) %>%
pairwise_t_test(
accuracy ~ method, paired = TRUE,
p.adjust.method = "bonferroni"
)
pwc
# Visualization: box plots with p-values
pwc <- pwc %>% add_xy_position(x = "method")
bxp +
stat_pvalue_manual(pwc, tip.length = 0, hide.ns = TRUE) +
labs(
subtitle = get_test_label(res.aov, detailed = TRUE),
caption = get_pwc_label(pwc)
)
#res3=subset(res2,method=="B"|method=="D", select=c(accuracy,pa, species,method))
library(Rmisc)
stat <- summarySE(res2, measurevar="accuracy", groupvars=c("method","pa"),na.rm = T)
stat
pd <- position_dodge(0.15) # move them .05 to the left and right
# Black error bars - notice the mapping of 'group=supp' -- without it, the error
# bars won't be dodged!
ggplot(stat, aes(x=method, y=accuracy, colour=pa, group=pa)) +
geom_errorbar(aes(ymin=accuracy-ci, ymax=accuracy+ci), colour="black", width=.2, position=pd) +
geom_point(position=pd, size=4)+
ylab("Prediction accuracy") +
scale_colour_hue(name="Data type",    # Legend label, use darker colors
breaks=c("pa", "abu"),
labels=c("Presence/absence", "Abundance"),
l=40) +                    # Use darker colors, lightness=40
theme_bw() +
theme(legend.justification=c(1,1),
legend.position=c(0.95,0.95),
legend.box.background=element_rect())  +             # Position legend in bottom right
theme(text = element_text(size = 20))+ geom_line()
knitr::opts_chunk$set(echo = TRUE)
paketit<-c("readr","tidyr","plyr","dplyr","magrittr","purrr","data.table","plotrix","jtools","sp","GISTools","rgdal","sf","spatialEco","ggplot2","lme4","nlme","ggpubr","rstatix","Rmisc","gdata")
lapply(paketit,library,character.only=T)
getwd()
localDir = "."
PredictionDir = file.path(localDir, "data")
samples = 1000
thin = 10
nChains = 4
modeltype = 1 #1 on pa-aineistolle
#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2
filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
"_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]
#määritellään periodit
period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")
#valitaan ennusteista ja havainnoista oikeat vuodet
pm1p1=mpred1[period1,]
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2
y1=Y[period1,]
y2=Y[period2,]
#lasketaan kuinka monta kertaa kullakin linjalla on k?yty
sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]
visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
visits1[i] = sum(sd1$Route==routes[i])
visits2[i] = sum(sd2$Route==routes[i])
}
#lasketaan kullekin linjalle (jolla on käyty kahdesti kummankin periodin aikana, yhteensä 592 kpl) keskiarvot periodeittain
#havainnot ja ennusteet erikseen, periodit 1 ja 2 erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)
Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)
for (i in 1:nsr){
take1 = which(sd1$Route == selroutes[i] )
take2 = which(sd2$Route == selroutes[i] )
Ap1[i,] = colMeans(pm1p1[take1,])
Ap2[i,] = colMeans(pm1p2[take2,])
Ay1[i,] = colMeans(y1[take1,]) #Suomen vesilinnut vain NA:ta
Ay2[i,] = colMeans(y2[take2,])
}
#lisätään kullekin linjalle koordinaatit
routeyear<-read.csv("studydesign.csv",header=T,sep=",")
xy<-read.csv("xy.csv",header=T,sep=",")
#koordinaateista puuttuu nollia
xy<-xy%>%
mutate(x = x * 1000) %>%
mutate(y = y * 1000)
#jotta koordinaatit saa liitettyä oikealle linjalle, tehdään taulukko, jossa reiteillä on molemmat koodaukset (alkuperäiset ja 1-2591)
Route<-unique(routeyear$Route)
routeid<-c(1:2591)
d<-data.frame(Route,routeid)
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")
Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")
Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")
Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")
#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")
#...ja vihdoin myös koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))
#tallenna tiedot
write.csv(Ay1,"pa_obs_per1.csv",row.names = F)
write.csv(Ay2,"pa_obs_per2.csv",row.names = F)
write.csv(Ap1,"pa_pred_per1.csv",row.names = F)
write.csv(Ap2,"pa_pred_per2.csv",row.names = F)
#luetaan sisään reitit, havainnot ja ennusteet
coordinates(Ay1)<-c("x","y")
plot(Ay1)
proj4string(Ay1) <-CRS("+init=EPSG:3035")
coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")
coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")
coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")
gridi<- readOGR(dsn="./gridit", layer="grid50km")
#gridi<- readOGR(dsn="./gridit", layer="grid100km")
proj4string(gridi)
plot(gridi)
#liiteään kuhunkin reittiin tieto, millä gridin ruudulla se on
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)
#ryhmitelään linjat gridiruuduittain ja lasketaan keskiarvot kullekin sarakkeelle, eli lajeittain.
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #jos jollain lajilla on yhdellä linjalla NA:ta se ei vaikuta keskiarvon laskemiseen.
write.csv(.,file = "pool_pa_obs_per1.csv",row.names=F)
#ja sama muille aineistoille
pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_pa_obs_per2.csv",row.names=F)
pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_pa_pred_per1.csv",row.names=F)
pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_pa_pred_per2.csv",row.names=F)
#luetaan aineisto takaisin sisään
paY1<-read.csv("pool_pa_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_pa_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_pa_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_pa_pred_per2.csv",header=T,sep=",")
#heivataan turhat sarakkeet
names(paY1)
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]
#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)
names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
#lasketaan erotukset periodin 1 ja 2 välilä
#pa
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1
#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1
#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
paKor<-paKor[,keep,drop=F]
#lasketaan korrelaatiot
paKor %>%
group_by(Yspecies) %>%
dplyr::summarise(pool_pa_change= cor(difPred, difY, use= "na.or.complete"))%T>%
write.csv('pa_pool50_results.csv',row.names=F)
modeltype = 2 #2 on abu-aineistolle
#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2
filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
"_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]
period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")
pm1p1=mpred1[period1,]
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2
y1=Y[period1,]
y2=Y[period2,]
sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]
visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
visits1[i] = sum(sd1$Route==routes[i])
visits2[i] = sum(sd2$Route==routes[i])
}
# lasketaan kullekin linjalle (jolla on k?yty kahdesti kummankin periodin aikana) keskiarvot periodeittain
#havainnot ja ennusteet erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)
Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)
for(j in 1:ns){
for (i in 1:nsr){
take1 = which(sd1$Route == selroutes[i] & y1[,j]>-1)
take2 = which(sd2$Route == selroutes[i] & y2[,j]>-1)
Ap1[i,j] = mean(pm1p1[take1,j]) #ei laske ennusteille keskiarvoa niiltä linjoilta, jotka ovat havainnoissa NA
Ap2[i,j] = mean(pm1p2[take2,j])
Ay1[i,j] = mean(y1[take1,j], na.rm=T) #NA:t jätetään huomiotta keskiarvoa laskettaessa
Ay2[i,j] = mean(y2[take2,j], na.rm=T)
}}
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")
Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")
Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")
Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")
#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")
#...ja koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))
#save observations and predictions for pooling in GIS
write.csv(Ay1,"abu_obs_per1.csv",row.names = F)
write.csv(Ay2,"abu_obs_per2.csv",row.names = F)
write.csv(Ap1,"abu_pred_per1.csv",row.names = F)
write.csv(Ap2,"abu_pred_per2.csv",row.names = F)
#luetaan sisään reitit koordinaatteineen
coordinates(Ay1)<-c("x","y")
proj4string(Ay1) <-CRS("+init=EPSG:3035")
coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")
coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")
coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")
#join data based on polygons
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #NA:t eivät vaikuta laskuihin
write.csv(.,file = "pool_abu_obs_per1.csv",row.names=F,na="")
pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_abu_obs_per2.csv",row.names=F,na="")
pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_abu_pred_per1.csv",row.names=F,na="")
pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
group_by(grid_id) %>%
summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
write.csv(.,file = "pool_abu_pred_per2.csv",row.names=F,na="")
paY1<-read.csv("pool_abu_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_abu_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_abu_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_abu_pred_per2.csv",header=T,sep=",")
#heivataan turhat sarakkeet
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]
#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)
names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
#seuraavaksi lasketaan erotukset periodin 1 ja 2 välilä
#abu
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1
#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1
#pa
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
abuKor<-abuKor[,keep,drop=F]
abuKor %>%
group_by(Yspecies) %>%
dplyr::summarise(pool_abu_change= cor(difPred, difY, use= "na.or.complete"))%T>%
write.csv('abu_pool50_results.csv',row.names=F)
observations=abuKor %>%
group_by(Yspecies) %>%
dplyr::summarise(Ngrid= length(which(!is.na(difPred))))
observations
#kaikki data sisään
res<-read.csv("results_with_NA.csv")
pool_pa<-read.csv("pa_pool50_results.csv")
pool_abu<-read.csv("abu_pool50_results.csv")
#100km gridi
#pool_pa<-read.csv("pa_pool100_results.csv")
#pool_abu<-read.csv("abu_pool100_results.csv")
#muokataan taulukoita
pool_pa$method=as.factor("pool_D")
pool_pa$pa=as.factor("pa")
pool_abu$method=as.factor("pool_D")
pool_abu$pa=as.factor("abu")
pool_pa=pool_pa %>% dplyr::rename(species = Yspecies, accuracy = pool_pa_change)
pool_abu=pool_abu %>% dplyr::rename(species = Yspecies,accuracy = pool_abu_change)
#yhdistetään kaikki tulokset samaan taulukkoon
res2=rbind(res,pool_abu,pool_pa)
str(res2)
summary(res2)
res2$accuracy[res2$species == "Emberiza_rustica" & res2$method == "pool_D" & res2$pa == "abu"] <- NA
res2$accuracy[res2$species == "Bonasa_bonasia" & res2$method == "pool_D" & res2$pa == "abu"] <- NA
#tallennetaan
write.csv(res2,"results_and_pooled.csv",row.names=F)
#plottailua
ggplot(res2, aes(x = method, y = accuracy, interaction = pa, colour = pa)) + geom_boxplot()
res3=subset(res2,method=="D"|method=="pool_D")
ggplot(res3, aes(x = method, y = accuracy, interaction = pa, colour = pa)) + geom_boxplot()
res3%>%
group_by(method,pa) %>%
summarise(means=mean(accuracy,na.rm=T),std.errors=std.error(accuracy,na.rm=T))
#fixed osan vertailua
A1=lme(accuracy~method*pa,data=res3,random=~1|species,method="ML",na.action="na.exclude")
A2=lme(accuracy~method+pa,data=res3,random=~1|species,method="ML",na.action="na.exclude")
A3=lme(accuracy~method,data=res3,random=~1|species,method="ML",na.action="na.exclude")
A4=lme(accuracy~pa,data=res3,random=~1|species,method="ML",na.action="na.exclude")
anova(A1,A2)
AIC(A1,A2,A3,A4)
summary(A1)
anova(A1)
#lopullinen malli
A1_final=lme(accuracy~method*pa,data=res3,random=~1|species,method="REML",na.action="na.exclude")
summary(A1_final)
#validointi
plot(A1_final)
E1=resid(A1_final, type="normalized")
F1=fitted(A1_final)
par(mfrow=c(2,2), mar=c(5,5,2,2))
plot(x=F1,y=E1,xlab="fitted",ylab="residuals")
abline(h=0,lty=2)
boxplot(E1~method,xlab="method",ylab="residuals",data=res3)
abline(h=0,lty=2)
boxplot(E1~pa,xlab="pa",ylab="residuals",data=res3)
abline(h=0,lty=2)
par(mfrow=c(1,1), mar=c(5,5,2,2))
boxplot(E1~species,xlab="species",ylab="residuals",data=res3)
abline(h=0,lty=2)
