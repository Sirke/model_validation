---
title: "part3"
author: "me"
date: "12 joulukuuta 2019"
output: html_document
---

# 3. Poolaus

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

paketit<-c("readr","tidyr","plyr","dplyr","magrittr","purrr","data.table","plotrix","jtools","sp","GISTools","rgdal","sf","spatialEco","ggplot2","lme4","nlme","ggpubr","rstatix","Rmisc","gdata","MCMCglmm","MuMIn")
lapply(paketit,library,character.only=T)
```

## 3.1 Presence/absence -aineisto


### 3.1.1 Aineisto sisälle ja periodien keskiarvojen lasku
Luetaan havainnot ja ennusteet sisään ja lasketaan kullekin lajille periodien 1 ja 2 ennustettujen ja todellisten esiintymistodennäköisyyksien reittikohtaiset keskiarvot.

```{r }
getwd()
localDir = "."
PredictionDir = file.path(localDir, "data")

samples = 1000
thin = 1000 #muista vaihtaa tämä!!
nChains = 4
modeltype = 1 #1 on pa-aineistolle

#model 1: data until 1999; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]

#määritellään periodit 
period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

#valitaan ennusteista ja havainnoista oikeat vuodet
pm1p1=mpred1[period1,]  
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2

y1=Y[period1,]
y2=Y[period2,]

#lasketaan kuinka monta kertaa kullakin linjalla on k?yty
sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

#lasketaan kullekin linjalle (jolla on käyty kahdesti kummankin periodin aikana, yhteensä 592 kpl) keskiarvot periodeittain
#havainnot ja ennusteet erikseen, periodit 1 ja 2 erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for (i in 1:nsr){
  take1 = which(sd1$Route == selroutes[i] )
  take2 = which(sd2$Route == selroutes[i] )
  Ap1[i,] = colMeans(pm1p1[take1,])
  Ap2[i,] = colMeans(pm1p2[take2,]) 
  Ay1[i,] = colMeans(y1[take1,]) #Suomen vesilinnut vain NA:ta
  Ay2[i,] = colMeans(y2[take2,])
}
```

Kolme reittiä taitaa olla Suomessa, joten niiden kohdalla vesilintujen havainnot ovat NA:ta.


### 3.1.2 Koordinaattien lisääminen 

Seuraavaksi liitetään kuhunkin reittiin koordinaatit.

```{r}
#lisätään kullekin linjalle koordinaatit
routeyear<-read.csv("studydesign.csv",header=T,sep=",")
xy<-read.csv("xy.csv",header=T,sep=",")

#koordinaateista puuttuu nollia
xy<-xy%>%
  mutate(x = x * 1000) %>%
  mutate(y = y * 1000) 

#jotta koordinaatit saa liitettyä oikealle linjalle, tehdään taulukko, jossa reiteillä on molemmat koodaukset (alkuperäiset ja 1-2591)
Route<-unique(routeyear$Route)
routeid<-c(1:2591)
d<-data.frame(Route,routeid)

#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja vihdoin myös koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))
```
Ylläolevaa koodin pätkää voi vielä siloitella jos on aikaa.

Tallennan havainnot ja ennusteet, jolloin poolausta on helpompi tarkistaa GIS:llä.

```{r}
#tallenna tiedot
write.csv(Ay1,"pa_obs_per1.csv",row.names = F)
write.csv(Ay2,"pa_obs_per2.csv",row.names = F)
write.csv(Ap1,"pa_pred_per1.csv",row.names = F)
write.csv(Ap2,"pa_pred_per2.csv",row.names = F)
```


### 3.1.3 Poolaus

Kootaan reitit 50 km x 50 km (tai 100x100 km) ruutuihin, eli lasketaan todelliset ja ennustetut esiintymistodennäköisyydet kaikkien yhteen ruutuun sijoittuvien reittien periodien keskiarvojen keskiarvoina.  

Luetaan ensin kaikki aineisto koordinaatteineen sisälle.  
Ay1 ja 2 ovat todellisia havaintoja, periodeittain. Ap1 ja 2 ovat ennusteita.

```{r}
#luetaan sisään reitit, havainnot ja ennusteet
coordinates(Ay1)<-c("x","y")
plot(Ay1)
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")
```

Gridit olen tehnyt jo aiemmin QGis:llä. 

```{r}
gridi<- readOGR(dsn="./gridit", layer="grid50km")
#gridi<- readOGR(dsn="./gridit", layer="grid100km")
proj4string(gridi)
plot(gridi)
```

Itse poolaus tapahtuu niin, että liitetään kuhunkin reittiin tieto, millä gridin ruudulla (id-numero) se on, jonka jälkeen ryhmitellään kaikki reitit gridiruuduittain ja lasketaan niille keskiarvot. Tallennan taas kaikki tiedot niin, että ne on helppo lukea ja tarkistaa GIS:llä.


```{r}
#liitetään kuhunkin reittiin tieto, millä gridin ruudulla se on
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)

#ryhmitelään linjat gridiruuduittain ja lasketaan keskiarvot kullekin sarakkeelle, eli lajeittain.
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #jos jollain lajilla on yhdellä linjalla NA:ta se ei vaikuta keskiarvon laskemiseen. 
  write.csv(.,file = "pool_pa_obs_per1.csv",row.names=F)

#ja sama muille aineistoille
pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_obs_per2.csv",row.names=F)

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per1.csv",row.names=F)

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per2.csv",row.names=F)
```

### 3.1.4 Poolatut ennustustarkkuudet

Lopulta lasketaan uudestaan ennustustarkkuudet poolatuilla arvoilla. Toistaiseksi vain metodilla D.

Luetaan aineisto takaisin sisään ja siivotaan sitä hieman:

```{r}
#luetaan aineisto takaisin sisään
paY1<-read.csv("pool_pa_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_pa_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_pa_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_pa_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
names(paY1)
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
```

Lasketaan periodien välinen muutos havainnoille ja ennusteille ja näiden korrelaatiot. (primitiivinen koodaus, voi parannella myöhemmin..)

```{r}
#lasketaan erotukset periodin 1 ja 2 välilä
#pa
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
paKor<-paKor[,keep,drop=F]

#lasketaan korrelaatiot
paKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_pa_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('pa_pool50_results.csv',row.names=F)
```

### 3.1.5 Metodi B

```{r}
#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))

#lasketaan korrelaatiot
paKor_B=paKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_pa_change= cor(Pper2, Yper2, use= "na.or.complete"))%T>%
  write.csv('pa_pool50_results_methodB.csv',row.names=F)
```

### 3.1.6 Metodit C ja A

```{r }
getwd()
localDir = "."
PredictionDir = file.path(localDir, "data")

samples = 1000
thin = 1000 #muista vaihtaa tämä!!
nChains = 4
modeltype = 1 #1 on pa-aineistolle

#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]

#määritellään periodit 
period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

#valitaan ennusteista ja havainnoista oikeat vuodet
pm2p1=mpred2[period1,]  
pm2p2=mpred2[period2,] #tähän vaihdetaan mpred2 ja pm2 eli malli2, jonka sovituksessa käytetty koko aineistoa

y1=Y[period1,]
y2=Y[period2,]

#lasketaan kuinka monta kertaa kullakin linjalla on k?yty
sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

#lasketaan kullekin linjalle (jolla on käyty kahdesti kummankin periodin aikana, yhteensä 592 kpl) keskiarvot periodeittain
#havainnot ja ennusteet erikseen, periodit 1 ja 2 erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for (i in 1:nsr){
  take1 = which(sd1$Route == selroutes[i] )
  take2 = which(sd2$Route == selroutes[i] )
  Ap1[i,] = colMeans(pm2p1[take1,])
  Ap2[i,] = colMeans(pm2p2[take2,]) 
  Ay1[i,] = colMeans(y1[take1,]) #Suomen vesilinnut vain NA:ta
  Ay2[i,] = colMeans(y2[take2,])
}
```


```{r}
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja vihdoin myös koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))

#tallenna tiedot
write.csv(Ay1,"pa_obs_per1.csv",row.names = F)
write.csv(Ay2,"pa_obs_per2.csv",row.names = F)
write.csv(Ap1,"pa_pred_per1.csv",row.names = F)
write.csv(Ap2,"pa_pred_per2.csv",row.names = F)

#luetaan sisään reitit, havainnot ja ennusteet
coordinates(Ay1)<-c("x","y")
plot(Ay1)
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")

#liitetään kuhunkin reittiin tieto, millä gridin ruudulla se on
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)

#ryhmitelään linjat gridiruuduittain ja lasketaan keskiarvot kullekin sarakkeelle, eli lajeittain.
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #jos jollain lajilla on yhdellä linjalla NA:ta se ei vaikuta keskiarvon laskemiseen. 
  write.csv(.,file = "pool_pa_obs_per1.csv",row.names=F)

#ja sama muille aineistoille
pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_obs_per2.csv",row.names=F)

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per1.csv",row.names=F)

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_pa_pred_per2.csv",row.names=F)

#luetaan aineisto takaisin sisään
paY1<-read.csv("pool_pa_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_pa_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_pa_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_pa_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
names(paY1)
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a

#lasketaan erotukset periodin 1 ja 2 välilä
#pa
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
paKor<-paKor[,keep,drop=F]

#lasketaan korrelaatiot, metodi C
paKor_C=paKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_pa_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('pa_pool50_results_methodC.csv',row.names=F)

#method A

#yhdistetään tulokset, havainnot ja ennusteet samaan dataframeen
paKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))

#lasketaan korrelaatiot
paKor_A=paKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_pa_change= cor(Pper2, Yper2, use= "na.or.complete"))%T>%
  write.csv('pa_pool50_results_methodA.csv',row.names=F)
```



## 3.2 Abundance -aineisto

Tehdään sama proseduuri myös abu-aineistolle.

### 3.2.1 Aineisto sisälle ja periodien keskiarvojen lasku

```{r}
modeltype = 2 #2 on abu-aineistolle

#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]

period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

pm1p1=mpred1[period1,]
pm1p2=mpred1[period2,] #pm1p2 = predictions by model 1 to period 2

y1=Y[period1,]
y2=Y[period2,]

sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

# lasketaan kullekin linjalle (jolla on k?yty kahdesti kummankin periodin aikana) keskiarvot periodeittain
#havainnot ja ennusteet erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for(j in 1:ns){
  for (i in 1:nsr){
    take1 = which(sd1$Route == selroutes[i] & y1[,j]>-1) 
    take2 = which(sd2$Route == selroutes[i] & y2[,j]>-1)
    Ap1[i,j] = mean(pm1p1[take1,j]) #ei laske ennusteille keskiarvoa niiltä linjoilta, jotka ovat havainnoissa NA
    Ap2[i,j] = mean(pm1p2[take2,j]) 
    Ay1[i,j] = mean(y1[take1,j], na.rm=T) #NA:t jätetään huomiotta keskiarvoa laskettaessa
    Ay2[i,j] = mean(y2[take2,j], na.rm=T)
  }}
```

### 3.2.2 Koordinaattien lisääminen

```{r}
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))

#save observations and predictions for pooling in GIS
write.csv(Ay1,"abu_obs_per1.csv",row.names = F)
write.csv(Ay2,"abu_obs_per2.csv",row.names = F)
write.csv(Ap1,"abu_pred_per1.csv",row.names = F)
write.csv(Ap2,"abu_pred_per2.csv",row.names = F)
```

### 3.2.3 Poolaus

```{r}
#luetaan sisään reitit koordinaatteineen
coordinates(Ay1)<-c("x","y")
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")

#join data based on polygons
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #NA:t eivät vaikuta laskuihin
  write.csv(.,file = "pool_abu_obs_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_obs_per2.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per2.csv",row.names=F,na="")
```

### 3.2.4 Poolatut ennustustarkkuudet

Aineiston siivous:

(Huom! Koodissa olioiden nimissä on hämäävästi 'pa' mutta nämä ovat silti abu-aineistoa.)

```{r}
paY1<-read.csv("pool_abu_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_abu_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_abu_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_abu_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
```

Muutokset periodien välillä ja korrelaatiot:

```{r}
#seuraavaksi lasketaan erotukset periodin 1 ja 2 välilä
#abu
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#pa
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
abuKor<-abuKor[,keep,drop=F]

abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_abu_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('abu_pool50_results.csv',row.names=F)
```

Kuinka moneen havaintopariin poolatut ennustustarkkuudet perustuvat? vieläkö mukana on lajeja, joista vain muutama havainto?

```{r}
observations=abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(Ngrid= length(which(!is.na(difPred))))

observations
```

Vaikea päätellä, mitkä korrelaatioista on luotettavasti laskettu. **Pohjansirkun poolattu korrelaatio perustuu edelleen vain kolmeen havaintopariin. Sen sijaan pyyn korrelaatio onkin nyt laskettu seitsemästä havaintoparista.** Huomion arvoista on myös se, että esimerkiksi sinirinnan havaintoparit ovat poolatussa aineistossa vain kahdeksan kun taas alkuperäinen korrelaatio on laskettu 34:stä havaintoparista. Poolaaminen voi siis auttaa joidenkin niiden lajien kohdalla, joille on vaikea löytää reittejä, joilla olisi käyty sekä periodi 1:llä että 2:lla. Mutta jos tarkastellaan vain sitä, kuinka harvasta gridiruudusta poolattu korrelaatio on laskettu, jää huomioimatta, että yhden ruudun "takana" voi olla useampia reittejä. Jos rajaksi asettaa saman 10 voi aineistosta pudota lajeja, joista oli useita havaintoja.


### 3.2.5 Metodi B

```{r}
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))

abuKor_B=abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_abu_change= cor(Pper2, Yper2, use= "na.or.complete"))%T>%
  write.csv('abu_pool50_results_methodB.csv',row.names=F)
```

### 3.2.6 Metodit A ja C

```{r}
modeltype = 2 #2 on abu-aineistolle

#model 1: data until 2006; model 2: full data
#mpred1: posterior mean based on model 1; mpred2: posterior mean based on model 2

filename = file.path(PredictionDir, paste("predictions_",c("pa","abundance")[modeltype],
                                          "_chains_",as.character(nChains),"_thin_", as.character(thin),"_samples_", as.character(samples),
                                          ".Rdata",sep = ""))
load(filename) #mpred1, mpred2, Y, studyDesign
routes=levels(studyDesign$Route)
nr=length(routes)
years=levels(studyDesign$Year)
ns=dim(mpred1)[2]

period1=(studyDesign$Year=="Year_1996" | studyDesign$Year=="Year_1997" | studyDesign$Year=="Year_1998" | studyDesign$Year=="Year_1999")
period2=(studyDesign$Year=="Year_2013" | studyDesign$Year=="Year_2014" | studyDesign$Year=="Year_2015" | studyDesign$Year=="Year_2016")

pm2p1=mpred2[period1,]
pm2p2=mpred2[period2,] #m2 eli käytetty koko aineistoa

y1=Y[period1,]
y2=Y[period2,]

sd1 = studyDesign[period1,]
sd2 = studyDesign[period2,]

visits1 = rep(NA,nr)
visits2 = rep(NA,nr)
for (i in 1:nr){
  visits1[i] = sum(sd1$Route==routes[i])
  visits2[i] = sum(sd2$Route==routes[i])
}

# lasketaan kullekin linjalle (jolla on k?yty kahdesti kummankin periodin aikana) keskiarvot periodeittain
#havainnot ja ennusteet erikseen
selroutes = routes[which(visits1>=2 & visits2>=2)]
nsr = length(selroutes)

Ap1=matrix(NA,nrow = nsr,ncol = ns)
Ap2=matrix(NA,nrow = nsr,ncol = ns)
Ay1=matrix(NA,nrow = nsr,ncol = ns)
Ay2=matrix(NA,nrow = nsr,ncol = ns)

for(j in 1:ns){
  for (i in 1:nsr){
    take1 = which(sd1$Route == selroutes[i] & y1[,j]>-1) 
    take2 = which(sd2$Route == selroutes[i] & y2[,j]>-1)
    Ap1[i,j] = mean(pm2p1[take1,j]) #ei laske ennusteille keskiarvoa niiltä linjoilta, jotka ovat havainnoissa NA
    Ap2[i,j] = mean(pm2p2[take2,j]) #tähän pitää myös vaihtaa pm2, jotta laskee oikeasta mallista (koko aineisto)
    Ay1[i,j] = mean(y1[take1,j], na.rm=T) #NA:t jätetään huomiotta keskiarvoa laskettaessa
    Ay2[i,j] = mean(y2[take2,j], na.rm=T)
  }}
```


```{r}
#matriisit on muutettava dataframeiksi
Ap1=as.data.frame(Ap1)  
Ap1=cbind(selroutes,Ap1)
setnames(Ap1,"selroutes","Route")

Ap2=as.data.frame(Ap2)
Ap2=cbind(selroutes,Ap2)
setnames(Ap2,"selroutes","Route")

Ay1=as.data.frame(Ay1)
Ay1=cbind(selroutes,Ay1)
setnames(Ay1,"selroutes","Route")

Ay2=as.data.frame(Ay2)
Ay2=cbind(selroutes,Ay2)
setnames(Ay2,"selroutes","Route")

#lisätään havaintoihin ja ennusteisiin ensin oikeat reittikoodit (1-2591)
Ap1<-left_join(Ap1,d,by="Route")
Ap2<-left_join(Ap2,d,by="Route")
Ay1<-left_join(Ay1,d,by="Route")
Ay2<-left_join(Ay2,d,by="Route")

#...ja koordinaatit
Ap1<-left_join(Ap1,xy,by=c("routeid"="route"))
Ap2<-left_join(Ap2,xy,by=c("routeid"="route"))
Ay1<-left_join(Ay1,xy,by=c("routeid"="route"))
Ay2<-left_join(Ay2,xy,by=c("routeid"="route"))

#save observations and predictions for pooling in GIS
write.csv(Ay1,"abu_obs_per1.csv",row.names = F)
write.csv(Ay2,"abu_obs_per2.csv",row.names = F)
write.csv(Ap1,"abu_pred_per1.csv",row.names = F)
write.csv(Ap2,"abu_pred_per2.csv",row.names = F)
```

```{r}
#luetaan sisään reitit koordinaatteineen
coordinates(Ay1)<-c("x","y")
proj4string(Ay1) <-CRS("+init=EPSG:3035")

coordinates(Ay2)<-c("x","y")
proj4string(Ay2) <-CRS("+init=EPSG:3035")

coordinates(Ap1)<-c("x","y")
proj4string(Ap1) <-CRS("+init=EPSG:3035")

coordinates(Ap2)<-c("x","y")
proj4string(Ap2) <-CRS("+init=EPSG:3035")

#join data based on polygons
pts.poly <- point.in.poly(Ay1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>% #NA:t eivät vaikuta laskuihin
  write.csv(.,file = "pool_abu_obs_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ay2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_obs_per2.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap1, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per1.csv",row.names=F,na="")

pts.poly <- point.in.poly(Ap2, gridi)
data<-as.data.frame(pts.poly)
data%>%
  group_by(grid_id) %>%
  summarise_at(vars(-Route), list(~mean(., na.rm=T))) %>%
  write.csv(.,file = "pool_abu_pred_per2.csv",row.names=F,na="")
```


```{r}
#luetaan aineisto takaisin sisään
paY1<-read.csv("pool_abu_obs_per1.csv",header=T,sep=",")
paY2<-read.csv("pool_abu_obs_per2.csv",header=T,sep=",")
papred1<-read.csv("pool_abu_pred_per1.csv",header=T,sep=",")
papred2<-read.csv("pool_abu_pred_per2.csv",header=T,sep=",")

#heivataan turhat sarakkeet
drops <- c("routeid","left","top","right","bottom","coords.x1","coords.x2")
paY1<-paY1[ , !(names(paY1) %in% drops)]
paY2<-paY2[ , !(names(paY2) %in% drops)]
papred1<-papred1[ , !(names(papred1) %in% drops)]
papred2<-papred2[ , !(names(papred2) %in% drops)]

#korjataan sarakkeiden lajinimet kunnollisiksi
a<-colnames(Y)
b<-"grid_id"
a<-c(b,a)

names(paY1)<-a
names(paY2)<-a
names(papred1)<-a
names(papred2)<-a
```


```{r}
#seuraavaksi lasketaan erotukset periodin 1 ja 2 välilä
#abu
#obs
pacounts_gather<-gather(paY1,key="Yspecies",value="Yper1",Acrocephalus_palustris:Vanellus_vanellus)
pacounts_gather2<-gather(paY2,key="Yspecies",value="Yper2",Acrocephalus_palustris:Vanellus_vanellus)
payhd<-left_join(pacounts_gather,pacounts_gather2,by=c("grid_id"="grid_id","Yspecies"="Yspecies"))
payhd$difY<-payhd$Yper2-payhd$Yper1

#pred
papred_gather<-gather(papred1,key="Pspecies",value="Pper1",Acrocephalus_palustris:Vanellus_vanellus)
papred_gather2<-gather(papred2,key="Pspecies",value="Pper2",Acrocephalus_palustris:Vanellus_vanellus)
payhdPred<-left_join(papred_gather,papred_gather2,by=c("grid_id"="grid_id","Pspecies"="Pspecies"))
payhdPred$difPred<-payhdPred$Pper2-payhdPred$Pper1

#abu
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))
keep<-c("Yspecies","difPred","difY")
abuKor<-abuKor[,keep,drop=F]

abuKor_C=abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_abu_change= cor(difPred, difY, use= "na.or.complete"))%T>%
  write.csv('abu_pool50_results_methodC.csv',row.names=F)
```

```{r}
abuKor<-left_join(payhd,payhdPred,by=c("grid_id"="grid_id","Yspecies"="Pspecies"))

abuKor_A=abuKor %>%
  group_by(Yspecies) %>%
  dplyr::summarise(pool_abu_change= cor(Pper2, Yper2, use= "na.or.complete"))%T>%
  write.csv('abu_pool50_results_methodA.csv',row.names=F)
```



## 3.3 Poolattujen ennustustarkkuuksien vertailu

### 3.3.1 Aineiston yhdistely

Selvitetään, paransiko poolaus ennustustarkkuuksia. Mikä on poolauksen ja aineistotyypin vaikutus ennustustarkkuuteen?

```{r}
#kaikki data sisään
res<-read.csv("results_with_NA.csv") #jo aiemmin lasketut ei-poolatut tarkkuudet
pool_pa<-read.csv("pa_pool50_results.csv")
pool_abu<-read.csv("abu_pool50_results.csv")

pool_paC=read.csv("pa_pool50_results_methodC.csv")
pool_paB=read.csv("pa_pool50_results_methodB.csv")
pool_paA=read.csv("pa_pool50_results_methodA.csv")

pool_abuC=read.csv("abu_pool50_results_methodC.csv")
pool_abuB=read.csv("abu_pool50_results_methodB.csv")
pool_abuA=read.csv("abu_pool50_results_methodA.csv")

#100km gridi
#pool_pa<-read.csv("pa_pool100_results.csv")
#pool_abu<-read.csv("abu_pool100_results.csv")

#muokataan taulukoita
pool_pa$method=as.factor("pool_D")
pool_pa$pa=as.factor("pa")

pool_abu$method=as.factor("pool_D")
pool_abu$pa=as.factor("abu")

pool_pa=pool_pa %>% dplyr::rename(species = Yspecies, accuracy = pool_pa_change)
pool_abu=pool_abu %>% dplyr::rename(species = Yspecies,accuracy = pool_abu_change)

pool_paC$method=as.factor("pool_C")
pool_paB$method=as.factor("pool_B")
pool_paA$method=as.factor("pool_A")

pool_paC$pa=as.factor("pa")
pool_paB$pa=as.factor("pa")
pool_paA$pa=as.factor("pa")

pool_abuC$method=as.factor("pool_C")
pool_abuB$method=as.factor("pool_B")
pool_abuA$method=as.factor("pool_A")

pool_abuC$pa=as.factor("abu")
pool_abuB$pa=as.factor("abu")
pool_abuA$pa=as.factor("abu")

helpabu=rbind(pool_abuC,pool_abuB,pool_abuA)
helppa=rbind(pool_paC,pool_paB,pool_paA)

helpabu=helpabu %>% dplyr::rename(species = Yspecies, accuracy = pool_abu_change)
helppa=helppa %>% dplyr::rename(species = Yspecies,accuracy = pool_pa_change)

help=rbind(helpabu,helppa)

#yhdistetään kaikki tulokset samaan taulukkoon
res2=rbind(res,pool_abu,pool_pa,help)
str(res2)
summary(res2)
```

Merkkaan **pohjansirkun ja pyyn poolatun abu-arvon NA:ksi** koska ne edelleen perustuvat vain kolmeen ja seitsemään havaintoon. 

```{r}
res2$accuracy[res2$species == "Emberiza_rustica" & res2$method == "pool_D" & res2$pa == "abu"] <- NA
res2$accuracy[res2$species == "Bonasa_bonasia" & res2$method == "pool_D" & res2$pa == "abu"] <- NA

res2$accuracy[res2$species == "Emberiza_rustica" & res2$method == "pool_C" & res2$pa == "abu"] <- NA
res2$accuracy[res2$species == "Bonasa_bonasia" & res2$method == "pool_C" & res2$pa == "abu"] <- NA

#tallennetaan
write.csv(res2,"results_and_pooled.csv",row.names=F)
```

Teen taulukon, jossa on lajikohtaiset ennustustarkkuudet ja traitsit.

```{r}
traits<-read.csv("traits_table.csv",sep = ";")
table=res2%>%unite("method",method,pa)%>%spread(method, accuracy)%>%inner_join(.,traits,by="species")
summary(table)
write.csv(table,"table.csv")
```



### 3.3.2 Aineiston tarkastelu

Tarkastellaan poolattuja ennustustarkkuuksia muihin metodeihin verrattuna:

```{r}
#plottailua
ggplot(res2, aes(x = method, y = accuracy,  colour = pa)) + geom_boxplot() +facet_grid(.~pa)
```


### 3.3.3 Analyysi 

Testataan vaikuttaako metodi ja poolaus ennustustarkkuuksiin. Käytän samaa sekamallia kuin aikaisemminkin.(En siis vertaile random-rakenteita enää). Laji on random-muuttuja. 

#### aineisto vielä hieman eri muotoon

```{r}
#aineisto uusiksi, lisään muuttujan 'pool' , joka jakaa tarkkuudet ei-poolattuihin ja poolattuihin
poolres=res2
poolres$pool=NA

poolres$pool[poolres$method=="A"|poolres$method=="B"|poolres$method=="C"|poolres$method=="D"]<-"NPo" 
poolres$pool[poolres$method=="pool_A"|poolres$method=="pool_B"|poolres$method=="pool_C"|poolres$method=="pool_D"]<-"Po" 
poolres$pool=as.factor(poolres$pool)
poolres$method=stringr::str_replace(poolres$method,'pool_','') 
poolres$method=as.factor(poolres$method)

#tarkistellaan taulukkona, tää ei nyt jostain syystä skulaa?!
poolres %>%
  group_by(method, pa, pool) %>%
  summarise(mean = mean(accuracy,na.rm=T),std.errors=std.error(accuracy,na.rm=T))

#plottailua
ggplot(poolres,aes(x=method,y=accuracy,color=pool))+geom_boxplot()+facet_grid(.~pa)

#tallenna
write.csv(poolres, "poolres.csv",row.names = F)
```

Analysoidaan pa ja abu datasetit erillään:

#### Pa-aineisto:

```{r}
#jaetaan aineisto pa ja abu aineistoihin
poolresPA=subset(poolres,pa=="pa")
poolresABU=subset(poolres,pa=="abu")
```


```{r}
#luetaan aineisto sisään, Multiphylo eli monta puuta
linnut <- read.nexus("output.nex")
#valitaan vain yksi puu, mikä tahansa sadasta
linnut2<-linnut[[99]]
#tehdään puusta malliin sopiva fylogeniarakenne
bm.birds<-inverseA(linnut2)$Ainv
```


```{r, cache=T,results="hide"}

M1<- MCMCglmm(accuracy ~ method * pool, random=~species, data = poolresPA,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

M2<- MCMCglmm(accuracy ~ method + pool, random=~species, data = poolresPA,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

M3<- MCMCglmm(accuracy ~ method, random=~species, data = poolresPA,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

M4<- MCMCglmm(accuracy ~ pool, random=~species, data = poolresPA,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
output1=model.sel(M1,M2,M3,M4)
output1
```

```{r}
summary(M3)
summary(M2)
```


```{r}
#vanhalla tyylillä ilman fylogeniaa
A1=lme(accuracy~method*pool,data=poolresPA,random=~1|species,method="ML",na.action="na.exclude")
A2=lme(accuracy~method+pool,data=poolresPA,random=~1|species,method="ML",na.action="na.exclude")
A3=lme(accuracy~method,data=poolresPA,random=~1|species,method="ML",na.action="na.exclude")
A4=lme(accuracy~pool,data=poolresPA,random=~1|species,method="ML",na.action="na.exclude")

anova(A1,A2)
AIC(A1,A2,A3,A4)

anova(A2,A3)
summary(A3)
anova(A3)
```

```{r}
#lopullinen malli
mfinal=lme(accuracy~method,data=poolresPA,random=~1|species,method="REML",na.action="na.exclude")
summary(mfinal)
```

```{r}
#validointi
plot(mfinal)

E1=resid(mfinal, type="normalized")
F1=fitted(mfinal)

par(mfrow=c(2,2), mar=c(5,5,2,2))
plot(x=F1,y=E1,xlab="fitted",ylab="residuals")
abline(h=0,lty=2)
boxplot(E1~method,xlab="method",ylab="residuals",data=poolresPA)
abline(h=0,lty=2)
par(mfrow=c(1,1), mar=c(5,5,2,2))
boxplot(E1~species,xlab="species",ylab="residuals",data=poolresPA)
abline(h=0,lty=2)
```

Eli pa-aineistolla vain metodilla on väliä, ei niinkään poolauksella?

#### Abu-aineisto:

```{r, cache=T,results="hide"}
N1<- MCMCglmm(accuracy ~ method * pool, random=~species, data = poolresABU,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

N2<- MCMCglmm(accuracy ~ method + pool, random=~species, data = poolresABU,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

N3<- MCMCglmm(accuracy ~ method, random=~species, data = poolresABU,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

N4<- MCMCglmm(accuracy ~ pool, random=~species, data = poolresABU,family="gaussian",  ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
output2=model.sel(N1,N2,N3,N4)
output2
```

```{r}
summary(N1)
```


```{r}
#fixed osan vertailua, abu aineisto:
A1=lme(accuracy~method*pool,data=poolresABU,random=~1|species,method="ML",na.action="na.exclude")
A2=lme(accuracy~method+pool,data=poolresABU,random=~1|species,method="ML",na.action="na.exclude")
A3=lme(accuracy~method,data=poolresABU,random=~1|species,method="ML",na.action="na.exclude")
A4=lme(accuracy~pool,data=poolresABU,random=~1|species,method="ML",na.action="na.exclude")

anova(A1,A2)
AIC(A1,A2,A3,A4)

summary(A1)
anova(A1)
```

Mutta abu aineistolla sekä metodilla että poolauksella yhdessä on vaikutusta?

```{r}
#lopullinen malli
mfinal=lme(accuracy~method*pool,data=poolresABU,random=~1|species,method="REML",na.action="na.exclude")
summary(mfinal)
```

```{r}
#validointi
plot(mfinal)

E1=resid(mfinal, type="normalized")
F1=fitted(mfinal)

par(mfrow=c(2,2), mar=c(5,5,2,2))
plot(x=F1,y=E1,xlab="fitted",ylab="residuals")
abline(h=0,lty=2)
boxplot(E1~method,xlab="method",ylab="residuals",data=poolresABU)
abline(h=0,lty=2)
par(mfrow=c(1,1), mar=c(5,5,2,2))
boxplot(E1~species,xlab="species",ylab="residuals",data=poolresABU)
abline(h=0,lty=2)
```

Abu-aineistolla sekä metodilla että poolauksella, ja niiden yhteisvaikutuksella on väliä.

### 3.3.5 Luottamusvälit


```{r}
stat <- summarySE(poolres, measurevar="accuracy", groupvars=c("method","pa","pool"),na.rm = T)
stat
stat$lower=stat$accuracy-stat$ci
stat$upper=stat$accuracy+stat$ci
#names(stat)[2] <- "Data_type"
#names(stat)[3] <- "Spatial_scale"
#stat$pool=revalue(stat$pool, c("NPo"="non-pooled", "Po"="pooled"))
knitr::kable(stat)
#names(res2)[4] <- "Data_type"

pd <- position_dodge(0.4) # move them .05 to the left and right
# Black error bars - notice the mapping of 'group=supp' -- without it, the error
# bars won't be dodged!
poolres$pa=revalue(poolres$pa, c("pa"="occurrence", "abu"="abundance"))
stat$pa=revalue(stat$pa, c("pa"="occurrence", "abu"="abundance"))
stat$pool=revalue(stat$pool, c("NPo"="local, non-pooled", "Po"="regional, pooled"))

stat$pa=factor(stat$pa, levels=c("occurrence","abundance"))

ggplot(stat, aes(y=accuracy, x=method, group=pool)) + 
  geom_point(aes(shape=pool),position=pd,size=2.5)  + 
  scale_shape_manual(values=c(19,17),name = "Spatial scale") + 
  geom_errorbar(aes(ymin=accuracy-ci, ymax=accuracy+ci), colour="black", width=.4, position=pd) +
  ylab("Prediction accuracy") +
  xlab("Validation method") +
  theme_bw() +
  theme(legend.justification=c(1,1),
          legend.box.background=element_rect()) +           
  theme(text = element_text(size = 15)) +
  geom_point(data=poolres,position=pd, size=0.5) +
  facet_grid(.~pa) + 
  geom_hline(yintercept = 0, linetype="dashed") +
  theme(legend.title = element_text(colour="black", size=10, 
                                      face="bold")) +
  theme(legend.text = element_text(colour="black", size=10, 
                                     face="bold"))

ggsave("plot3_pa_pool_method.png")
```


