---
title: "part5"
author: "me"
date: "12 joulukuuta 2019"
output: html_document
---

# 4. Traits analyysi

Selvitetään ovatko tietyt lajiominaisuudet kytköksissä ennustustarkkuuteen.  
Analysoin pa ja abu-aineistot erillään. Edellisissä analyyseissahan aineistot on analysoitu yhdessä (metodin ja aineistotyypin (pa/abu) interaktio). Meneekö tämä siis oikein?

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

getwd()
paketit<-c("visreg","nlme","readr","tidyr","plyr","dplyr","magrittr","purrr","ggplot2","ape","geiger","MuMIn","psych","Hmisc","MCMCglmm")
lapply(paketit,library,character.only=T)
```

## 4.1 Aineisto sisään ja taulukoiden kokoaminen

Valitsen tarkasteluun vain poolatut ennustustarkkuudet. Järjestelen aineiston eri tavalla (vanhaan koodiin sopivaksi).

```{r }
#aineiston valinta, leväyttäminen ja uudelleen nimeäminen
poolres<-read.csv("poolres.csv")

#lisätään lajiominaisuudet taulukkoon
traits<-read.csv("traits_table.csv",sep = ";")
results<-inner_join(poolres,traits,by="species")
str(results)
results$species=as.factor(results$species)

#uusi muuttuja, massan logaritmi
results$logmass<-log(results$Mass)

#uusi muuttuja, log-muunnettu prevalenssi
results$PrevS=log(results$Prev)

#arcsin-muunnos (kokeiltu)
#asinTransform <- function(p) { asin(sqrt(p)) }
#results$PrevS=asinTransform(results$Prev)

#logit-muunnos (kokeilin, antaa ihan samanlaiset residuaalit)
#logitTransform <- function(p) { log(p/(1-p)) }
#results$PrevS=logitTransform(results$Prev)

#tallenna tarvittaessa omaksi taulukokseen
#write.csv(results,"accuracies_traits.csv",row.names = F)
```

## 4.2 Aineiston tarkastelu

Tarkastellaan aineistoa kuvaajista.

Poolattu 50 x 50 km aineisto, pa ja abu, habitat:

```{r }
#jaetaan aineisto pa ja abu aineistoihin
resPA=subset(results,pa=="pa")
resABU=subset(results,pa=="abu")

#pa aineisto
ggplot(resPA, aes(x=Hab, y=accuracy)) + 
  geom_boxplot(aes(fill=method)) + facet_grid(. ~pool ) +
  ggtitle("occurrence data")

ggplot(resABU, aes(x=Hab, y=accuracy)) + 
  geom_boxplot(aes(fill=method)) + facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

Migration

```{r }
#pa aineisto
ggplot(resPA, aes(x=Mig, y=accuracy)) + 
  geom_boxplot(aes(fill=method))+ facet_grid(. ~pool ) +
  ggtitle("occurrence data")

ggplot(resABU, aes(x=Mig, y=accuracy)) + 
  geom_boxplot(aes(fill=method))+ facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

Prevalence

```{r }
#pa aineisto
ggplot(resPA, aes(x=PrevS, y=accuracy,color=method)) + 
  geom_point () + 
  geom_smooth(method=lm) +
  ggtitle("occurrence data") +
  facet_grid(. ~pool) 
#abu
ggplot(resABU, aes(x=PrevS, y=accuracy,color=method)) + 
  geom_point()+ 
   geom_smooth(method=lm) +
  facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

Mass

```{r }
#pa aineisto
ggplot(resPA, aes(x=logmass, y=accuracy,color=method)) + 
  geom_point () + 
  geom_smooth(method=lm) +
  ggtitle("occurrence data") +
  facet_grid(. ~pool) 
#abu
ggplot(resABU, aes(x=logmass, y=accuracy,color=method)) + 
  geom_point()+ 
   geom_smooth(method=lm) +
  facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

Tarkistan massan ja prevalenssin korrelaation:

```{r}
pairs(results[8:9])
cor(results$logmass,results$PrevS)
```

Massa ja yleisyys eivät näytä korreloivan. 


## 4.3 Fylogenia

BirdTree.org palvelusta on haettu lintujen sukupuu (tai itseasiassa tiedosto sisältää 100 vaihtoehtoista sukupuuta, joista valitaan yksi). 

MCMCglmm-funktio vaatii fylogenian tietyssä rakenteessa:
 
ginverse= a list of sparse inverse matrices (A−1) that are proportional to the covariance
structure of the random effects. The names of the matrices should correspond
to columns in data that are associated with the random term. All levels of the
random term should appear as rownames for the matrices.

```{r}
#luetaan aineisto sisään, Multiphylo eli monta puuta
linnut <- read.nexus("output.nex")
#valitaan vain yksi puu, mikä tahansa sadasta
linnut2<-linnut[[99]]
#tehdään puusta malliin sopiva fylogeniarakenne
bm.birds<-inverseA(linnut2)$Ainv
```


## 4.4 Analyysit

Selvitetään, vaikuttavatko lajien ominaisuudet (muuttokäyttäytyminen 'Mig', elinympäristö 'Hab', paino 'logMass' tai prevalenssi 'Prev') ennustustarkkuuteen. Analyysissä pitäisi huomioida fylogenia eli, että lajit voivat olla ominaisuuksiltaan samankaltaisia (ja siten omata myös samanlaiset ennustustarkkuudet) läheisen sukulaisuussuhteen takia. Mukana nyt myös ominaisuuksien mahdolliset yhdysvaikutukset metodin ja poolauksen kanssa.

### 4.4.1 Pa-aineisto

Luodaan mallivaihtoehdot.

```{r echo=TRUE, message=FALSE, cache=T}
#priori
prior<-list(R=list(V=1, nu=0.00), G=list(G1=list(V=1, nu=0.00))) #mutta tämä ei nyt ole malleissa mukana (?)

m1<- MCMCglmm(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m2<- MCMCglmm(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool, random=~ species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m3<- MCMCglmm(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m4<- MCMCglmm(accuracy ~ Hab*pool +PrevS*pool + Mig*pool + logmass*pool + method, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m5<- MCMCglmm(accuracy ~ Hab + PrevS + Mig + logmass + method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m6<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m7<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m8<- MCMCglmm(accuracy ~ Hab*method +PrevS*method  + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m9<- MCMCglmm(accuracy ~ Hab*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m10<- MCMCglmm(accuracy ~ Prev*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m11<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m12<- MCMCglmm(accuracy ~ Hab*method + Mig*method  + pool, random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m13<- MCMCglmm(accuracy ~ Hab*method + logmass*method + pool, random=~species, data=      resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m14<- MCMCglmm(accuracy ~ PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m15<- MCMCglmm(accuracy ~ PrevS*method +  logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m16<- MCMCglmm(accuracy ~ Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m17<- MCMCglmm(accuracy ~ Hab*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m18<- MCMCglmm(accuracy ~ PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)

m19<- MCMCglmm(accuracy ~ Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)

m20<- MCMCglmm(accuracy ~ logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)
```



```{r}
#mallin valintaa MuMin paketin avulla
output1<-model.sel(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,m15,m16,m17,m18,m19,m20) 
output1
```

Malli 12, accuracy ~ Hab x method + Mig x method  + pool, on näistä paras. Seuraavaksi paras malli sisältää myös painon ja metodin interaktion.

Malli 12 näyttää tältä:

```{r}
summary(m12)
#plot(m12$Sol, auto.layout=F)
```

Mutta koska aiempi simppelimpi analyysi vihjasi ettei poolauksella ole merkitystä ennustustarkkuuksiin pa-aineistolla, kokeilen vielä mallia, jossa jätän poolauksen pois ja vertaan sitä parhaaseen malliin.

```{r echo = T, results = 'hide', cache=T}
#mitä jos tiputtaisi vielä poolauksen?
m21<- MCMCglmm(accuracy ~ Hab*method + Mig*method , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
output2=model.sel(m12,m21)
output2
```

Uusi malli on hitusen parempi, se on simppelimpi (vähemmän parametreja) ja sillä on alempi AICc. 

```{r}
summary(m21)
#plot(m21$Sol, auto.layout=F)
```

Interaktiot metodin kanssa ovat merkitseviä vain C ja D metodeilla. Mitäs jos tiputtaa vielä interaktiot pois?

```{r echo=TRUE, message=FALSE, cache=T}
#mitä jos tiputtaisi vielä poolauksen?
m22<- MCMCglmm(accuracy ~ Hab*method + Mig , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m23<- MCMCglmm(accuracy ~ Hab + method*Mig , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
output3=model.sel(m21,m22,m23)
output3
```

Poolauksen voisi siis tiputtaa pois mutta ei interaktioita metodin kanssa. Tuloksia tulkitsisin niin, että muuttokäyttäytymisen suhteen kaikenlaiset linnut ovat vaikeampia ennustaa jos käytämme metodia C tai D.  


Mallinvalinnasta AIC-arvojen avulla voi lukea [täältä](http://webhome.auburn.edu/~tds0009/PDFs/arnold%20et%20al.%202010.pdf). Tosin tämän artikkelin mukaan olisin ehkä ennemmin vertaillut weights-arvoja. Lainaus: "If the primary objective of modeling is to evaluate the relative importance of many potential predictor variables, such as in many habitat selection
studies, then summing Akaike model weights across all models that include that variable can be a useful approach."

### 4.4.2 Abu-aineistolle

Vaihdetaan aineistoa. Sama fylogeniarakenne toimii tässäkin vaikka abu-aineistossa C ja D metodeilla on vain 118 havaintoa, eli fylogeniapuussa on pari ylimääräistä oksaa. Aiemmin gls-funktiolla tämä haittasi mallin sovittamista, tässä ilmeisesti ei haittaa.

```{r echo=TRUE, message=FALSE, cache=T}
m1A<- MCMCglmm(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m2A<- MCMCglmm(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool, random=~ species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m3A<- MCMCglmm(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m4A<- MCMCglmm(accuracy ~ Hab*pool +PrevS*pool + Mig*pool + logmass*pool + method, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m5A<- MCMCglmm(accuracy ~ Hab + PrevS + Mig + logmass + method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m6A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m7A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m8A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method  + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m9A<- MCMCglmm(accuracy ~ Hab*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m10A<- MCMCglmm(accuracy ~ Prev*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m11A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m12A<- MCMCglmm(accuracy ~ Hab*method + Mig*method  + pool, random=~species, data = 
resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m13A<- MCMCglmm(accuracy ~ Hab*method + logmass*method + pool, random=~species, data=      resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m14A<- MCMCglmm(accuracy ~ PrevS*method + Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m15A<- MCMCglmm(accuracy ~ PrevS*method +  logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m16A<- MCMCglmm(accuracy ~ Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m17A<- MCMCglmm(accuracy ~ Hab*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m18A<- MCMCglmm(accuracy ~ PrevS*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)

m19A<- MCMCglmm(accuracy ~ Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)

m20A<- MCMCglmm(accuracy ~ logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=103000, burnin=300, thin=100)
```

```{r}
#mallin valintaa MuMin paketin avulla
output4<-model.sel(m1A,m2A,m3A,m4A,m5A,m6A,m7A,m8A,m9A,m10A,m11A,m12A,m13A,m14A,m15A,m16A,m17A,m18A,m19A,m20A) 
output4
```

Malli 10, accuracy ~ Prev x method + Mig x method + logmass x method + pool, on paras. 

Toiseksi paras malli, 14 accuracy ~ PrevS x method + Mig x method  + pool, ei sisällä painoa selittävänä tekijänä.

```{r}
summary(m10A)
#plot(m10A$Sol, auto.layout=F)
```

Kokeilen huvikseen mallia ilman poolausta:

```{r}
m21A<- MCMCglmm(accuracy ~ Prev*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```


```{r}
output5=model.sel(m10A,m21A)
output5
```






