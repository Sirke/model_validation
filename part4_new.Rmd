---
title: "part5"
author: "me"
date: "12 joulukuuta 2019"
output: html_document
---

# 4. Traits analyysi

Selvitetään ovatko tietyt lajiominaisuudet kytköksissä ennustustarkkuuteen.  
Analysoin pa ja abu-aineistot erillään.

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

getwd()
paketit<-c("lme4","nlme","readr","tidyr","plyr","dplyr","magrittr","purrr","ggplot2","ape","MuMIn","Hmisc","MCMCglmm","bayesplot","rstanarm","ggeffects","viridis")
lapply(paketit,library,character.only=T)
```

## 4.1 Aineisto sisään ja taulukoiden kokoaminen

Log-muunnetaan prevalenssi ja massa.

```{r }
#aineiston valinta, leväyttäminen ja uudelleen nimeäminen
poolres<-read.csv("poolres.csv")

#lisätään lajiominaisuudet taulukkoon
traits<-read.csv("traits_table.csv",sep = ";")
results<-inner_join(poolres,traits,by="species")
str(results)
results$species=as.factor(results$species)

#uusi muuttuja, massan logaritmi
results$logmass<-log(results$Mass)

#uusi muuttuja, log-muunnettu prevalenssi
results$PrevS=log(results$Prev)

#arcsin-muunnos (kokeiltu)
#asinTransform <- function(p) { asin(sqrt(p)) }
#results$PrevS=asinTransform(results$Prev)

#logit-muunnos (kokeilin, antaa ihan samanlaiset residuaalit)
#logitTransform <- function(p) { log(p/(1-p)) }
#results$PrevS=logitTransform(results$Prev)

#tallenna tarvittaessa omaksi taulukokseen
#write.csv(results,"accuracies_traits.csv",row.names = F)
```

## 4.2 Aineiston tarkastelu

Tarkastellaan aineistoa kuvaajista. Jaetaan aineisto ensin pa ja abu-aineistoihin.

```{r }
#jaetaan aineisto pa ja abu aineistoihin
resPA=subset(results,pa=="pa")
resABU=subset(results,pa=="abu")
```

*Habitat*

```{r }
ggplot(resPA, aes(x=Hab, y=accuracy)) + 
  geom_boxplot(aes(fill=method)) + facet_grid(. ~pool ) +
  ggtitle("occurrence data")

ggplot(resABU, aes(x=Hab, y=accuracy)) + 
  geom_boxplot(aes(fill=method)) + facet_grid(. ~pool ) +
  ggtitle("abundance data")
```
*Migration*

```{r }
#pa aineisto
ggplot(resPA, aes(x=Mig, y=accuracy)) + 
  geom_boxplot(aes(fill=method))+ facet_grid(. ~pool ) +
  ggtitle("occurrence data")

ggplot(resABU, aes(x=Mig, y=accuracy)) + 
  geom_boxplot(aes(fill=method))+ facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

*Prevalence*

```{r }
#pa aineisto
ggplot(resPA, aes(x=PrevS, y=accuracy,color=method)) + 
  geom_point () + 
  geom_smooth(method=lm) +
  ggtitle("occurrence data") +
  facet_grid(. ~pool) 
#abu
ggplot(resABU, aes(x=PrevS, y=accuracy,color=method)) + 
  geom_point()+ 
   geom_smooth(method=lm) +
  facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

*Mass*

```{r }
#pa aineisto
ggplot(resPA, aes(x=logmass, y=accuracy,color=method)) + 
  geom_point () + 
  geom_smooth(method=lm) +
  ggtitle("occurrence data") +
  facet_grid(. ~pool) 
#abu
ggplot(resABU, aes(x=logmass, y=accuracy,color=method)) + 
  geom_point()+ 
   geom_smooth(method=lm) +
  facet_grid(. ~pool ) +
  ggtitle("abundance data")
```

```{r}
#muokataan muuttujia hieman
resPA$Mig <- factor(resPA$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
resPA$pool <- factor(resPA$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
resPA$Hab <- factor(resPA$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))
```

```{r}
resPA %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Hab, accuracy,fill=migration)) +
  theme_bw() +
  geom_boxplot()+
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE) 
ggsave("pa_raw_data_plot_factors.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
resPA %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(logmass, accuracy,color=migration)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("log(Mass)")+
  ylab("Prediction accuracy")+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("pa_raw_data_plot_mass_by_migration.pdf",device="pdf",width=25,height=12,units="cm")

resPA %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(PrevS, accuracy,color=migration)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  #geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("log(Prevalence)")+
  ylab("Prediction accuracy")+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("pa_raw_data_plot_prev_by_migration.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
#tai jokainen trait erikseen
resPA %>%
  ggplot(aes(Hab, accuracy)) +
  theme_bw() +
  geom_boxplot(aes(colour=factor(Hab)))+
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
 theme(legend.position="top")+
  labs(color = "Habitat preference")+
  theme(legend.position='none')
ggsave("pa_raw_data_plot_habitat.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("pa_raw_data_plot_habitat.png",device="png",width=25,height=12,units="cm")
```

```{r}
resPA %>%
  mutate(Mig = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Mig, accuracy)) +
  theme_bw() +
  geom_boxplot(aes(colour=factor(Mig)))+
  facet_grid(pool ~ method)+
  xlab("Migration behaviour")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
 theme(legend.position="top")+
  labs(color = "Habitat preference")+
  theme(legend.position='none')
ggsave("pa_raw_data_plot_migration.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("pa_raw_data_plot_migration.png",device="png",width=25,height=12,units="cm")
```

```{r}
resPA %>%
  ggplot(aes(exp(logmass), accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("Mass (kg)")+
  ylab("Prediction accuracy")+
   scale_x_continuous(breaks=c(0,5000, 10000),labels=c("0","5","10"))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("pa_raw_data_plot_mass.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
resPA %>%
  ggplot(aes(exp(PrevS), accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("Prevalence")+
  ylab("Prediction accuracy")+
  scale_x_continuous(breaks=c(0.3,0.6, 0.9),labels=c("0.3","0.6","0.9"))+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("pa_raw_data_plot_mass.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
#muokataan muuttujia hieman
resABU$Mig <- factor(resABU$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
resABU$pool <- factor(resABU$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
resABU$Hab <- factor(resABU$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))
```

```{r}
resABU %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  #ggplot(aes(Hab, accuracy, color = migration, group=migration)) +
  ggplot(aes(Hab, accuracy,fill=migration)) +
  theme_bw() +
  geom_boxplot()+
  #geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE) 
ggsave("abu_raw_data_plot_factors.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(logmass, accuracy,color=migration)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("log(Mass)")+
  ylab("Prediction accuracy")+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("abu_raw_data_plot_mass_by_migration.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(PrevS, accuracy,color=migration)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  #geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("log(Prevalence)")+
  ylab("Prediction accuracy")+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)

ggsave("abu_raw_data_plot_prev_by_migration.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
#tai jokainen trait erikseen:
resABU %>%
  ggplot(aes(Hab, accuracy)) +
  theme_bw() +
  geom_boxplot(aes(colour=factor(Hab)))+
  #geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
 theme(legend.position="top")+
  labs(color = "Habitat preference")+
  theme(legend.position='none')
ggsave("abu_raw_data_plot_habitat.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("abu_raw_data_plot_habitat.png",device="png",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  mutate(Mig = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Mig, accuracy)) +
  theme_bw() +
  geom_boxplot(aes(colour=factor(Mig)))+
  facet_grid(pool ~ method)+
  xlab("Migration behaviour")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  theme(legend.position='none')
ggsave("abu_raw_data_plot_migration.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("abu_raw_data_plot_migration.png",device="png",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  ggplot(aes(exp(logmass), accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("Mass (kg)")+
  ylab("Prediction accuracy")+
   scale_x_continuous(breaks=c(0,5000, 10000),labels=c("0","5","10"))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("abu_raw_data_plot_mass.pdf",device="pdf",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  ggplot(aes(exp(PrevS), accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("Prevalence")+
  ylab("Prediction accuracy")+
  scale_x_continuous(breaks=c(0.3,0.6, 0.9),labels=c("0.3","0.6","0.9"))+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("abu_raw_data_plot_prev.pdf",device="pdf",width=25,height=12,units="cm")

#log-skaalalla samat:
resABU %>%
  ggplot(aes(logmass, accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("log(Mass)")+
  ylab("Prediction accuracy")+
   #scale_x_continuous(breaks=c(0,5000, 10000),labels=c("0","5","10"))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("abu_raw_data_plot_mass_logscale.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("abu_raw_data_plot_mass_logscale.png",device="png",width=25,height=12,units="cm")
```

```{r}
resABU %>%
  ggplot(aes(PrevS, accuracy)) +
  theme_bw() +
  geom_point () + 
  geom_smooth(method=lm) +
  facet_grid(pool ~ method)+
  xlab("log(Prevalence)")+
  ylab("Prediction accuracy")+
  #scale_x_continuous(breaks=c(0.3,0.6, 0.9),labels=c("0.3","0.6","0.9"))+
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)
ggsave("abu_raw_data_plot_prevalence_logscale.pdf",device="pdf",width=25,height=12,units="cm")
ggsave("abu_raw_data_plot_prevalence_logscale.png",device="png",width=25,height=12,units="cm")
```



Tarkistan massan ja prevalenssin korrelaation:

```{r}
pairs(results[8:9])
cor(results$logmass,results$PrevS)
```

Massa ja yleisyys eivät näytä korreloivan suuresti. 


## 4.3 Fylogenia

BirdTree.org palvelusta on haettu lintujen sukupuu (tai itseasiassa tiedosto sisältää 100 vaihtoehtoista sukupuuta, joista valitaan yksi). 

MCMCglmm-funktio vaatii fylogenian tietyssä rakenteessa:
 
ginverse= a list of sparse inverse matrices (A−1) that are proportional to the covariance
structure of the random effects. The names of the matrices should correspond
to columns in data that are associated with the random term. All levels of the
random term should appear as rownames for the matrices.

```{r}
#luetaan aineisto sisään, Multiphylo eli monta puuta
linnut <- read.nexus("output.nex")
#valitaan vain yksi puu, mikä tahansa sadasta
linnut2<-linnut[[99]]
#tehdään puusta malliin sopiva fylogeniarakenne
bm.birds<-inverseA(linnut2)$Ainv
```


## 4.4 Analyysit MCMCglmm

Selvitetään, vaikuttavatko lajien ominaisuudet (muuttokäyttäytyminen 'Mig', elinympäristö 'Hab', paino 'logMass' tai prevalenssi 'Prev') ennustustarkkuuteen. Analyysissä pitäisi huomioida fylogenia eli, että lajit voivat olla ominaisuuksiltaan samankaltaisia (ja siten omata myös samanlaiset ennustustarkkuudet) läheisen sukulaisuussuhteen takia. Mukana nyt myös ominaisuuksien mahdolliset yhdysvaikutukset metodin ja poolauksen kanssa.

### 4.4.1 Pa-aineisto, mallit MCMCglmm-funktiolla

Luodaan mallivaihtoehdot.

```{r }
#priori
#prior<-list(R=list(V=1, nu=0.00), G=list(G1=list(V=1, nu=0.00))) #mutta tämä ei nyt ole malleissa mukana (?)

#m1<- MCMCglmm(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m2<- MCMCglmm(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool, random=~ species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m3<- MCMCglmm(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m4<- MCMCglmm(accuracy ~ Hab*pool +PrevS*pool + Mig*pool + logmass*pool + method, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m5<- MCMCglmm(accuracy ~ Hab + PrevS + Mig + logmass + method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m6<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m7<- MCMCglmm(accuracy ~ Hab*method +PrevS*method  + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m8<- MCMCglmm(accuracy ~ Hab*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m9<- MCMCglmm(accuracy ~ Prev*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m10<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m11<- MCMCglmm(accuracy ~ Hab*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m12<- MCMCglmm(accuracy ~ Hab*method + logmass*method + pool, random=~species, data=      resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m13<- MCMCglmm(accuracy ~ PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m14<- MCMCglmm(accuracy ~ PrevS*method +  logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m15<- MCMCglmm(accuracy ~ Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m16<- MCMCglmm(accuracy ~ Hab*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m17<- MCMCglmm(accuracy ~ PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m18<- MCMCglmm(accuracy ~ Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

#m19<- MCMCglmm(accuracy ~ logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r, cache=T,results="hide"}
#priori
#prior<-list(R=list(V=1, nu=0.00), G=list(G1=list(V=1, nu=0.00))) #mutta tämä ei nyt ole malleissa mukana (?)

m1<- MCMCglmm(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m2<- MCMCglmm(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool, random=~ species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m3<- MCMCglmm(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m4<- MCMCglmm(accuracy ~ Hab*pool +PrevS*pool + Mig*pool + logmass*pool + method, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m5<- MCMCglmm(accuracy ~ Hab + PrevS + Mig + logmass + method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m6<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m7<- MCMCglmm(accuracy ~ Hab*method +PrevS*method  + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m8<- MCMCglmm(accuracy ~ Hab*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m9<- MCMCglmm(accuracy ~ PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m10<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m11<- MCMCglmm(accuracy ~ Hab*method + Mig*method  + pool, random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000,pr=TRUE)

m12<- MCMCglmm(accuracy ~ Hab*method + logmass*method + pool, random=~species, data=      resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m13<- MCMCglmm(accuracy ~ PrevS*method + Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m14<- MCMCglmm(accuracy ~ PrevS*method +  logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m15<- MCMCglmm(accuracy ~ Mig*method + logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m16<- MCMCglmm(accuracy ~ Hab*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m17<- MCMCglmm(accuracy ~ PrevS*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m18<- MCMCglmm(accuracy ~ Mig*method  + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m19<- MCMCglmm(accuracy ~ logmass*method + pool, random=~species, data = resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

Mumin-paketin model.sel näyttää toimivan myös MCMCglmm-tuotoksen kanssa.

```{r}
#mallin valintaa MuMin paketin avulla
output1<-model.sel(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,m15,m16,m17,m18,m19) 
output1
```

Malli 11, accuracy ~ Hab x method + Mig x method  + pool, on näistä paras. Seuraavaksi paras malli sisältää myös painon ja metodin interaktion.

Malli 11 näyttää tältä:

### 4.4.2 Parhaimman mallin validointi kuvaajista

```{r}
summary(m11)
plot(m11$Sol, auto.layout=F) #printit vie ihan hirveästi tilaa tällä koodilla

#posterior <- as.matrix(m11)

#plot_title <- ggtitle("Posterior distributions","with medians and 80% intervals")
#mcmc_areas(posterior,
           #pars = c("logmass", "method", "pool","species"),
          #prob = 0.8) + plot_title
#EI TOIMI.
```

#### Kuvaaja

```{r}
#ggeffects-paketin ggpredict-funktio tekee ennusteen suoraan ggplot2-yhteensopivasti
#luo 96 ennustetta eli kullekin kombinaatiolle yhden predicted arvon
mydf=ggpredict(m11, terms=c("Hab", "Mig","method","pool"))
mydf
#plot-funktio osaa suoraan plotata aineiston, pienillä säädöillä voi muuttaa esitystapaa
plot(mydf, limits = c(-0.4, 1))+ 
  facet_grid(method ~ pool) 

#tai sitten voi muotoilla vapaammin omanlaisensa kuvaajan perinteiseen tapaan ggplot-funktiolla
pd <- position_dodge(0.7) # move them .05 to the left and right

ggplot(data = mydf, aes(x, predicted, colour = group, group=group)) +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(panel ~ facet) 

#muokataan muuttujia hieman
mydf$group <- factor(mydf$group, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
mydf$panel <- factor(mydf$panel, levels=c("NPo", "Po"), labels=c("local", "regional"))
mydf$x <- factor(mydf$x, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

mydf %>%
  arrange(predicted) %>%
  mutate(migration = factor(group, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(x, predicted, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(panel ~ facet)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))
```

```{r}
#type="random"" eli random muuttuja huomioidaan tässä ja intervallien pitäisi olla prediction intervallit
mydf2=ggpredict(m11, terms=c("Hab", "Mig","method","pool"),type="random")
mydf2
#plot-funktio osaa suoraan plotata aineiston, pienillä säädöillä voi muuttaa esitystapaa
plot(mydf2, limits = c(-0.4, 1))+ 
  facet_grid(method ~ pool) 

#tai sitten voi muotoilla vapaammin omanlaisensa kuvaajan perinteiseen tapaan ggplot-funktiolla
pd <- position_dodge(0.7) # move them .05 to the left and right

ggplot(data = mydf2, aes(x, predicted, colour = group, group=group)) +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(panel ~ facet) 

#muokataan muuttujia hieman
mydf2$group <- factor(mydf2$group, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
mydf2$panel <- factor(mydf2$panel, levels=c("NPo", "Po"), labels=c("local", "regional"))
mydf2$x <- factor(mydf2$x, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

mydf2 %>%
  arrange(predicted) %>%
  mutate(migration = factor(group, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(x, predicted, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(panel ~ facet)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))
```

Ihan samat tulokset. En ole ihan varma toimiiko ggpredict-funktio sittenkään aivan moitteettomasti mcmcglmm-objektille.

```{r}
#yritän tehdä samat ennusteet itse predict.MCMCglmm-funktiolla
#luon samanlaisen uuden aineiston mallille syötettäväksi (tosin mydf oli ilman lajia ja accuracya)
newdata1 <- expand.grid(method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       Hab=c("CU","FO","MM","WE"),accuracy=0,species="Acrocephalus_palustris")

g=predict.MCMCglmm(object = m11, newdata1, interval = "prediction", type = "response", marginal=m9A$Random$species)
#g=predict.MCMCglmm(object = m11, newdata1, interval = "prediction", type = "response") #mikä näiden ero on? mitä tuo marginalisointi meinaa?
#g=predict.MCMCglmm(object = m11, newdata1, interval = "confidence", type = "response", marginal=m9A$Random$species) #näin en saa confidence intervalleja haettua, johtuuko siitä, että species on vain yksi laji?
#g=predict.MCMCglmm(object = m11, newdata1, interval = "confidence", type = "response")#tämä toimii
g=cbind(newdata1,g)

pd <- position_dodge(0.7) # move them .05 to the left and right

#muokataan muuttujia hieman
g$Mig <- factor(g$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
g$pool <- factor(g$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
g$Hab <- factor(g$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

g %>%
  arrange(fit) %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Hab, fit, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))

```

```{r}
#yritän tehdä samat ennusteet itse predict.MCMCglmm-funktiolla
#luon samanlaisen uuden aineiston mallille syötettäväksi (tosin mydf oli ilman lajia ja accuracya)
newdata1 <- expand.grid(method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       Hab=c("CU","FO","MM","WE"),accuracy=0,species="Acrocephalus_palustris")

#g=predict.MCMCglmm(object = m11, newdata1, interval = "prediction", type = "response", marginal=m9A$Random$species)
g=predict.MCMCglmm(object = m11, newdata1, interval = "prediction", type = "response") #mikä näiden ero on? mitä tuo marginalisointi meinaa?
#g=predict.MCMCglmm(object = m11, newdata1, interval = "confidence", type = "response", marginal=m9A$Random$species) #näin en saa confidence intervalleja haettua, johtuuko siitä, että species on vain yksi laji?
#g=predict.MCMCglmm(object = m11, newdata1, interval = "confidence", type = "response")#tämä toimii
g=cbind(newdata1,g)

pd <- position_dodge(0.7) # move them .05 to the left and right

#muokataan muuttujia hieman
g$Mig <- factor(g$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
g$pool <- factor(g$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
g$Hab <- factor(g$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

g %>%
  arrange(fit) %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Hab, fit, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE) 
ggsave("pa_predictions_plot.pdf",device="pdf",width=20,height=12,units="cm")
```



```{r}
#yritän muuttaa luottamusvälit lyhyemmiksi
l=as.character(unique(resPA$species))
newdata2 <- expand.grid(method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       Hab=c("CU","FO","MM","WE"),accuracy=0,species=c(l)) #luon ennusteet kaikista kombinaatioista kaikille lajeille

u=predict.MCMCglmm(object = m11, newdata2, interval = "confidence", type = "response") 
#u=predict.MCMCglmm(object = m11, newdata2, interval = "confidence", type = "response", marginal=m9A$Random$species) #tällä ei toimi, eli mitä? jos haluaa marginalisoida random efektin, niin silloin ei voi saada confidence intervalleja, ainakaan tällä newdatalla, jossa kaikki lajit
u=cbind(newdata2,u)

pd <- position_dodge(0.7) # move them .05 to the left and right

#muokataan muuttujia hieman
u$Mig <- factor(u$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
u$pool <- factor(u$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
u$Hab <- factor(u$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

u %>%
  arrange(fit) %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Hab, fit, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))
```
Huom!
Note that, *prediction interval* relies strongly on the assumption that the residual errors are normally distributed with a constant variance. So, you should only use such intervals if you believe that the assumption is approximately met for the data at hand.

```{r}
#ilman uutta aineistoa, fitted arvot
r=predict(m11,marginal=~species,type="response",interval="confidence") #ei prediction!!
r=predict.MCMCglmm(object = m11, interval = "confidence", type = "response")
r=predict.MCMCglmm(object = m11, interval = "prediction", type = "response")
r=predict.MCMCglmm(object = m11, interval = "prediction", type = "response", marginal=m9A$Random$species)
r=cbind(resPA,r)

pd <- position_dodge(0.7) # move them .05 to the left and right

#muokataan muuttujia hieman
r$Mig <- factor(r$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
r$pool <- factor(r$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))
r$Hab <- factor(r$Hab, levels=c("CU", "FO","MM","WE"), labels=c("cultural", "forests","mountain/mire", "wetland"))

r %>%
  arrange(fit) %>%
  mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
  ggplot(aes(Hab, fit, color = migration, group=migration)) +
  theme_bw() +
  geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1, position=pd) +
  geom_point(position=pd) + 
  facet_grid(pool ~ method)+
  xlab("Habitat preference")+
  ylab("Prediction accuracy")+
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.9))
```

### 4.4.3 Muita vaihtoehtoisia malleja

Koska aiempi simppelimpi analyysi vihjasi ettei poolauksella ole merkitystä ennustustarkkuuksiin pa-aineistolla, kokeilen vielä mallia, jossa jätän poolauksen pois ja vertaan sitä parhaaseen malliin.

```{r echo=TRUE, results='hide', cache=TRUE}
#mitä jos tiputtaisi vielä poolauksen?
#m20<- MCMCglmm(accuracy ~ Hab*method + Mig*method , random=~species, data = 
#resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r, cache=T,results="hide"}
#mitä jos tiputtaisi vielä poolauksen?
m20<- MCMCglmm(accuracy ~ Hab*method + Mig*method , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
output2=model.sel(m11,m20)
output2
```

Uusi malli on hitusen parempi, se on simppelimpi (vähemmän parametreja) ja sillä on alempi AICc. 

```{r}
summary(m20)
plot(m20$Sol, auto.layout=F)
```

Interaktiot metodin kanssa ovat merkitseviä vain C ja D metodeilla. Mitäs jos tiputtaa vielä jomman kumman interaktion pois?

```{r, cache=T,results="hide"}
#mitä jos tiputtaisi vielä interaktiot?
m21<- MCMCglmm(accuracy ~ Hab*method + Mig , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m22<- MCMCglmm(accuracy ~ Hab + method*Mig , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

Mitä jos method on päävaikutuksena?

```{r, cache=T,results="hide"}
m23<- MCMCglmm(accuracy ~ Hab + method + Mig , random=~species, data = 
resPA,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

mallien vertailu

```{r}
output3=model.sel(m20,m21,m22,m23)
output3
```

Poolauksen voisi siis tiputtaa pois mutta ei interaktioita metodin kanssa. Tuloksia tulkitsisin niin, että muuttokäyttäytymisen suhteen kaikenlaiset linnut ovat vaikeampia ennustaa jos käytämme metodia C tai D. Habitaatissa tapahtuu kaikenlaista jännää.


Mallinvalinnasta AIC-arvojen avulla voi lukea [täältä](http://webhome.auburn.edu/~tds0009/PDFs/arnold%20et%20al.%202010.pdf). Tosin tämän artikkelin mukaan olisin ehkä ennemmin vertaillut weights-arvoja. Lainaus: "If the primary objective of modeling is to evaluate the relative importance of many potential predictor variables, such as in many habitat selection
studies, then summing Akaike model weights across all models that include that variable can be a useful approach."

### 4.4.4 Abu-aineisto, glmmMCMC-funktiolla

Vaihdetaan aineistoa. Sama fylogeniarakenne toimii tässäkin vaikka abu-aineistossa C ja D metodeilla on vain 118 havaintoa, eli fylogeniapuussa on pari ylimääräistä oksaa. Aiemmin gls-funktiolla tämä haittasi mallin sovittamista, tässä ilmeisesti ei haittaa.

```{r, cache=T,results="hide"}
m1A<- MCMCglmm(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m2A<- MCMCglmm(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool, random=~ species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m3A<- MCMCglmm(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m4A<- MCMCglmm(accuracy ~ Hab*pool +PrevS*pool + Mig*pool + logmass*pool + method, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m5A<- MCMCglmm(accuracy ~ Hab + PrevS + Mig + logmass + method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m6A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m7A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method  + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m8A<- MCMCglmm(accuracy ~ Hab*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m9A<- MCMCglmm(accuracy ~ PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m10A<- MCMCglmm(accuracy ~ Hab*method +PrevS*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m11A<- MCMCglmm(accuracy ~ Hab*method + Mig*method  + pool, random=~species, data = 
resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m12A<- MCMCglmm(accuracy ~ Hab*method + logmass*method + pool, random=~species, data=      resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m13A<- MCMCglmm(accuracy ~ PrevS*method + Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m14A<- MCMCglmm(accuracy ~ PrevS*method +  logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m15A<- MCMCglmm(accuracy ~ Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m16A<- MCMCglmm(accuracy ~ Hab*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m17A<- MCMCglmm(accuracy ~ PrevS*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m18A<- MCMCglmm(accuracy ~ Mig*method  + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)

m19A<- MCMCglmm(accuracy ~ logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```

```{r}
#mallin valintaa MuMin paketin avulla
output4<-model.sel(m1A,m2A,m3A,m4A,m5A,m6A,m7A,m8A,m9A,m10A,m11A,m12A,m13A,m14A,m15A,m16A,m17A,m18A,m19A) 
output4
```

Malli 9, accuracy ~ Prev x method + Mig x method + logmass x method + pool, on paras. 

Toiseksi paras malli, 13 accuracy ~ PrevS x method + Mig x method  + pool, ei sisällä painoa selittävänä tekijänä.

### 4.4.5 Parhaimman mallin validointi kuvaajista

```{r}
summary(m9A)
plot(m9A$Sol, auto.layout=F)
```

#### Kuvaaja ennusteista

```{r}
#yritys jossa logmass ja prevS ovat vuorotellen keskiarvoja
mean_mass2=mean(resABU$logmass)
#med_mass=median(resABU$logmass)
min_prev2 <- min(resABU$PrevS)
max_prev2 <- max(resABU$PrevS)
newdata3 <- expand.grid(PrevS = (seq(from = min_prev2,to = max_prev2, length.out = 10)),
                       #logmass = mean_mass2,
                       logmass=9.2,
                       method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       accuracy=0,
                       species="Acrocephalus_palustris")

c=predict.MCMCglmm(object = m9A, newdata = newdata3, interval = "prediction", type = "response", marginal=m9A$Random$species)
#c=predict.MCMCglmm(object = m9A, newdata = newdata3, interval = "prediction", type = "response")
c=cbind(newdata3,c)

#muokataan muuttujia hieman
c$Mig <- factor(c$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
c$pool <- factor(c$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))

c %>% arrange(PrevS) %>%
  mutate(PrevS=exp(PrevS))%>%
mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
ggplot(aes(x=PrevS, y=fit, colour = migration, group=migration, ymin = lwr, ymax = upr)) +
  theme_bw()+
  geom_line() +
  geom_ribbon(alpha = 0.2, color = FALSE)+
  facet_grid(pool ~ method) +
  xlab("Prevalence")+
  ylab("Prediction accuracy")+
  scale_x_continuous(breaks=c(0.3,0.6, 0.9),labels=c("0.3","0.6","0.9"))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)

ggsave("prevalence.png",device="png",width=20,height=12,units="cm")
```

```{r}
#PrevS keskiarvoksi ja uudet arvot massalle
mean_prev=mean(resABU$PrevS)
#med_mass=median(resABU$logmass)
min_mass <- min(resABU$logmass)
max_mass<- max(resABU$logmass)
newdata4 <- expand.grid(logmass = (seq(from = min_mass,to = max_mass, length.out = 10)),
                       PrevS = mean_prev,
                       method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       accuracy=0,
                       species="Acrocephalus_palustris")

t=predict.MCMCglmm(object = m9A, newdata = newdata4, interval = "prediction", type = "response", marginal=m9A$Random$species)
t=cbind(newdata4,t)

#muokataan muuttujia hieman
t$Mig <- factor(t$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
t$pool <- factor(t$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))

t %>% arrange(logmass) %>%
    mutate(logmass=exp(logmass))%>%
mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
ggplot(aes(x=logmass, y=fit, colour = migration, group=migration, ymin = lwr, ymax = upr)) +
  theme_bw()+
  geom_line() +
  geom_ribbon(alpha = 0.2, color = FALSE)+
  facet_grid(pool ~ method)+
  xlab("Mass (kg)")+
  ylab("Prediction accuracy")+
  scale_x_continuous(breaks=c(0,5000, 10000),labels=c("0","5","10"))+ 
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_fill_viridis(discrete = TRUE)

ggsave("mass.png",device="png",width=20,height=12,units="cm")
```

```{r}
#yritys jossa logmass ja prevS ovat vuorotellen keskiarvoja
mean_mass2=mean(resABU$logmass)
#med_mass=median(resABU$logmass)
min_prev2 <- min(resABU$PrevS)
max_prev2 <- max(resABU$PrevS)
newdata3 <- expand.grid(PrevS = (seq(from = min_prev2,to = max_prev2, length.out = 10)),
                       logmass = mean_mass2,
                       method = c("A","B","C","D"),
                       pool = c("NPo","Po"),
                       Mig = c("L", "R","S"),
                       accuracy=0,
                       species="Acrocephalus_palustris")

c=predict.MCMCglmm(object = m9A, newdata = newdata3, interval = "confidence", type = "response") #miksi tämä ei toimi? en saa confidence intervalleja abu-aineiston tuloksille
```


```{r}
#ei uutta aineistoa
#mcmcglmm-paketin omalla predict-funktiolla
#t=predict.MCMCglmm(object = m9A, interval = "confidence", type = "response", marginal=m9A$Random$species)
b=predict(m9A,marginal=~species,type="response",interval="confidence") #vai interval=prediction?
#b=predict(m9A,marginal=~species,type="response",interval="prediction") #vai interval=prediction?
b=cbind(resABU,b)

#muokataan muuttujia hieman
b$Mig <- factor(b$Mig, levels=c("L", "R", "S"), labels=c("long-distance", "resident","short-distance"))
b$pool <- factor(b$pool, levels=c("NPo", "Po"), labels=c("local", "regional"))

b %>% arrange(logmass) %>%
mutate(migration = factor(Mig, levels=c("long-distance", "short-distance", "resident"))) %>%
ggplot(aes(x=logmass, y=fit, colour = migration, group=migration, ymin = lwr, ymax = upr)) +
  geom_line() +
  geom_ribbon(alpha = 0.2, color = FALSE)+
  facet_grid(pool ~ method)+
  xlab("log(mass)")+
  ylab("Prediction accuracy")
```



### 4.4.6 Muita vaihtoehtoisia malleja

Kokeilen huvikseen mallia ilman poolausta:

```{r, cache=T,results="hide"}
m20A<- MCMCglmm(accuracy ~ PrevS*method + Mig*method + logmass*method + pool, random=~species, data = resABU,family="gaussian",ginverse=list(species=bm.birds),nitt=1003000, burnin=3000, thin=1000)
```


```{r}
output5=model.sel(m9A,m20A)
output5
```


## 4.5 Analyysit, lmer-funktiolla, ilman fylogeniaa


### 4.5.1 pa-aineisto

```{r, cache=T,results="hide"}
#luodaan eri mallivaihtoehtoja
m1B<- lmer(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool + (1|species),data= resPA, REML = F)
m2B<- lmer(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool + (1|species),data= resPA, REML = F)
m3B<- lmer(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m4B<- lmer(accuracy ~ Hab*pool + PrevS*pool +  Mig*pool + logmass*pool + method + (1|species),data= resPA, REML = F)
m5B<- lmer(accuracy ~ Hab + PrevS + Mig + logmass + method + pool + (1|species), data=resPA, REML = F)
m6B<- lmer(accuracy ~ Hab*method + PrevS*method + Mig*method + pool + (1|species),data= resPA, REML = F)
m7B<- lmer(accuracy ~ Hab*method + PrevS*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m8B<- lmer(accuracy ~ Hab*method + Mig*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m9B<- lmer(accuracy ~ PrevS*method + Mig*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m10B<- lmer(accuracy ~ Hab*method + PrevS*method + pool + (1|species),data= resPA, REML = F)
m11B<- lmer(accuracy ~ Hab*method +  Mig*method +  pool + (1|species),data= resPA, REML = F)
m12B<- lmer(accuracy ~ Hab*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m13B<- lmer(accuracy ~ PrevS*method + Mig*method + pool + (1|species),data= resPA, REML = F)
m14B<- lmer(accuracy ~ PrevS*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m15B<- lmer(accuracy ~ Mig*method + logmass*method + pool + (1|species),data= resPA, REML = F)
m16B<- lmer(accuracy ~ Hab*method + pool + (1|species),data= resPA, REML = F)
m17B<- lmer(accuracy ~ PrevS*method + pool + (1|species),data= resPA, REML = F)
m18B<- lmer(accuracy ~ Mig*method +  pool + (1|species),data= resPA, REML = F)
m19B<- lmer(accuracy ~ logmass*method + pool + (1|species),data= resPA, REML = F)
```

```{r}
#mallin valintaa MuMin paketin avulla
output5<-model.sel(m1B,m2B,m3B,m4B,m5B,m7B,m8B,m9B,m10B,m11B,m12B,m13B,m14B,m15B,m16B,m17B,m18B,m19B) 
output5 
```

```{r}
summary(m11B)
```


Pa-aineistolla tulokset pysyvät samoina. Valittaisiin edelleen malli 11, nyt tosin seuraavaksi paras malli on vain 1.08 AIC-yksikön päässä parhaasta. Ei niin vakuuttava ero seuraavaksi parhaaseen malliin. 

### 4.5.2 abu-aineisto

```{r, cache=T,results="hide"}
#luodaan eri mallivaihtoehtoja
m1B<- lmer(accuracy ~ Hab*method*pool + PrevS*method*pool + Mig*method*pool + logmass*method*pool + (1|species),data= resABU, REML = F)
m2B<- lmer(accuracy ~ Hab*method + Hab*pool +PrevS*method + PrevS*pool + Mig*method + Mig*pool + logmass*method + logmass*pool + (1|species),data= resABU, REML = F)
m3B<- lmer(accuracy~ Hab*method +PrevS*method + Mig*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m4B<- lmer(accuracy ~ Hab*pool + PrevS*pool +  Mig*pool + logmass*pool + method + (1|species),data= resABU, REML = F)
m5B<- lmer(accuracy ~ Hab + PrevS + Mig + logmass + method + pool + (1|species), data=resABU, REML = F)
m6B<- lmer(accuracy ~ Hab*method + PrevS*method + Mig*method + pool + (1|species),data= resABU, REML = F)
m7B<- lmer(accuracy ~ Hab*method + PrevS*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m8B<- lmer(accuracy ~ Hab*method + Mig*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m9B<- lmer(accuracy ~ PrevS*method + Mig*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m10B<- lmer(accuracy ~ Hab*method + PrevS*method + pool + (1|species),data= resABU, REML = F)
m11B<- lmer(accuracy ~ Hab*method +  Mig*method +  pool + (1|species),data= resABU, REML = F)
m12B<- lmer(accuracy ~ Hab*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m13B<- lmer(accuracy ~ PrevS*method + Mig*method + pool + (1|species),data= resABU, REML = F)
m14B<- lmer(accuracy ~ PrevS*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m15B<- lmer(accuracy ~ Mig*method + logmass*method + pool + (1|species),data= resABU, REML = F)
m16B<- lmer(accuracy ~ Hab*method + pool + (1|species),data= resABU, REML = F)
m17B<- lmer(accuracy ~ PrevS*method + pool + (1|species),data= resABU, REML = F)
m18B<- lmer(accuracy ~ Mig*method +  pool + (1|species),data= resABU, REML = F)
m19B<- lmer(accuracy ~ logmass*method + pool + (1|species),data= resABU, REML = F)
```

```{r}
#mallin valintaa MuMin paketin avulla
output6<-model.sel(m1B,m2B,m3B,m4B,m5B,m6B,m7B,m8B,m9B,m10B,m11B,m12B,m13B,m14B,m15B,m16B,m17B,m18B,m19B) 
output6 
```

```{r}
summary(m6B)
```


Abu-aineistolla tulokset muuttuvat. Nyt parhaaksi malliksi valikoituukin malli 6, joka sisältääkin habitaatin, prevalenssin ja migraation (vs. prev, mig ja mass, jotka valikoituivat kun fylogenia huomioitiin). Eroa seuraavaan malliin vain 1.88 (malli3, joka sisältää kaikki traitit).

